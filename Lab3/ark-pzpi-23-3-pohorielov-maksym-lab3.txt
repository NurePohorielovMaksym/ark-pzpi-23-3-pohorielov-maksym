МІНІСТЕРСТВО НАУКИ І ОСВІТИ УКРАЇНИ


ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ










Кафедра «Програмна інженерія»








ЗВІТ
з лабораторної роботи №3
 з дисципліни: «Аналіз та рефакторинг коду»
з теми: «Програмна система для автоматизації годування домашніх тварин»










 
Виконав:                                                                   Прийняв:
ст. гр. ПЗПІ-23-3                                                      ст. викл. каф. ПІ
Погорєлов М. І.                                                        Сокорчук Ігор Петрович




















Харків 2025
1. ІСТОРІЯ ЗМІН


№
	Дата
	Опис змін
	Версія звіту
	1
	18.12.2025
	початок роботи
	0.1
	2
	20.12.2025
	редагування попередньої версії
	1
	

2. ЗАВДАННЯ


Метою роботи є розробка та програмна реалізація бізнес-логіки серверної частини для обробки основних запитів користувачів, створення функцій адміністрування для керування даними та правами доступу, а також фінальна перевірка працездатності всього серверного коду.


3. ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Архітектурні рішення
Для реалізації серверної частини системи (Backend) обрано багатошарову архітектуру (Layered Architecture). Цей підхід забезпечує чітке розділення відповідальності між компонентами системи, полегшує тестування та подальшу підтримку коду, див.рисунок Б.2.
Система побудована на базі платформи Node.js з використанням фреймворку Express.js для обробки HTTP-запитів.
3.1.1 Структурні шари системи
Архітектура додатка розділена на три основні логічні шари:
1. Шар презентації (Controllers / Routes):
* Призначення: Відповідає за обробку вхідних HTTP-запитів, валідацію вхідних даних (тіла запиту, параметрів шляху) та формування HTTP-відповідей.
* Реалізація: Маршрутизатори (routes/*.js) перенаправляють запити до відповідних методів контролерів (controllers/*.js).
* Особливість: Контролери не містять складної бізнес-логіки; вони лише делегують виконання завдань сервісам. Використовується патерн asyncHandler для централізованої обробки помилок.
2. Шар бізнес-логіки (Services):
* Призначення: Містить основні правила функціонування системи. Тут відбуваються перевірки (наприклад, чи належить пристрій користувачу, чи достатньо корму для видачі порції), обчислення та оркестрація викликів до репозиторіїв.
* Реалізація: Файли у директорії services/*.js.
* Приклад: Функція feedNow у сервісі перевіряє права доступу, поточний рівень корму, списує його та реєструє подію.
3. Шар доступу до даних (Repositories / Data Access):
* Призначення: Відповідає за безпосередню взаємодію з базою даних (MS SQL Server). Цей шар ізолює SQL-запити від бізнес-логіки.
* Реалізація: Файли у директорії repositories/*.js. Використовуються параметризовані SQL-запити для запобігання SQL-ін'єкціям.
3.1.2 Проектування REST API
Взаємодія клієнтської частини з сервером реалізована через RESTful API. Архітектурні рішення API включають:
* Використання стандартних HTTP методів: GET (читання), POST (створення/дії), PATCH (часткове оновлення), DELETE (видалення).
* Ресурс-орієнтовані URL (наприклад, /api/users/:id/role).
* Стандартизована структура відповіді JSON: { "ok": true, "data": ... } або { "ok": false, "message": "Error description" }.
3.1.3 Управління станом та даними
В якості системи управління базами даних обрано Microsoft SQL Server. Архітектурне рішення для БД включає:
* Реляційна модель: Використання зв'язків (One-to-Many) між сутностями Users -> Pets, Devices -> Events.
* Цілісність даних: Використання зовнішніх ключів (Foreign Keys) для забезпечення консистентності (наприклад, неможливо створити графік годування для неіснуючої тварини).
* Транзакційність: Критичні операції (наприклад, списання корму та запис логу події) виконуються послідовно.
3.2 Математична модель визначення оптимальної порції корму
Для автоматизації процесу визначення оптимальної порції корму в системі реалізовано математичну модель, що базується на обчисленні енергетичних потреб тварини (Energy Requirements). Алгоритм розрахунку спирається на загальноприйняті ветеринарні формули визначення рівня основного обміну речовин — RER (Resting Energy Requirement) та добової потреби в енергії — DER (Daily Energy Requirement).
3.2.1 Вхідні параметри моделі
Для виконання розрахунку використовується вектор вхідних параметрів P:
P={m,A,,},
де
m— маса тіла тварини, кг, m>0;
A — рівень фізичної активності тварини (Activity Level),
A∈{Low,Medium,High};
​ — тип корму,
∈{Dry,Wet}.
3.2.2 Розрахунок базового метаболізму (RER)
Першим етапом є визначення енергії, необхідної для підтримання життєдіяльності організму тварини у стані спокою. Для цього використовується аллометричне рівняння, відоме як закон Клайбера, яке описує залежність швидкості метаболізму від маси тіла:


RER=70⋅,                                (3.1)
де
RER — рівень базового метаболізму, ккал/добу;
m— маса тіла тварини, кг;
коефіцієнт 70 та показник степеня 0.75 є емпіричними константами, характерними для ссавців.
3.2.3 Розрахунок добової потреби в енергії (DER)
Для визначення повної добової потреби в енергії враховується рівень фізичної активності тварини за допомогою коефіцієнта активності kactk_{act}kact​. Добова потреба в енергії обчислюється за формулою:


DER=RER⋅.                                (3.2)


Значення коефіцієнта ​ визначається відповідно до рівня активності A та наведене в таблиці 3.1. 


Таблиця 3.1 — Значення коефіцієнта активності тварини
Рівень активності A
	
	Характеристика
	Low (низький)
	1.2
	Малорухливий спосіб життя, літні тварини
	Medium (середній)
	1.5
	Помірна активність
	High (високий)
	1.8
	Активні ігри, тренування
	3.2.4 Розрахунок маси корму
Для переведення енергетичної потреби в фізичну масу корму використовується показник калорійної щільності корму , ккал/г. Для основних типів корму прийнято усереднені значення:


 =                  (3.3)




Загальна добова маса корму ​ визначається за формулою:


=,                                        (3.4)
де
 — добова норма корму, г.
3.2.5 Визначення разової порції
Система передбачає дворазове харчування тварини протягом доби. Тому маса однієї порції  визначається як половина добової норми з округленням до найближчого цілого значення для коректної роботи механізму дозування:


=                                     (3.5)
3.3.1. Аутентифікація та користувачі 
1. Реєстрація користувача - api/auth/register (POST)
Запит використовується для створення нового облікового запису в системі. Користувач передає свої реєстраційні дані (електронну пошту, пароль, ім’я), які проходять валідацію на сервері. 
Приклад запиту:
  {
"email": "testuser06@gmail.com",
"password": "Testuser10",
"fullName": "Test06"
  }
Приклад успішної відповіді
  {
"ok": true,
 "user": {
 "id": 4,
                 "email": "testuser06@gmail.com",
"fullName": "Test06"
},
  }
2. Авторизація користувача - api/auth/login (POST)
Запит призначений для входу користувача в систему. Користувач надсилає електронну пошту та пароль, які перевіряються на відповідність збереженим у базі даних даним. У разі успішної автентифікації сервер генерує JWT-токен, який містить ідентифікатор користувача та використовується для доступу до захищених ресурсів API.
Приклад запиту:
  {
                    "email": "testuser06@gmail.com",
                    "password": "Testuser10"
  }
Приклад успішної  відповіді:
  {
"ok": true,
"user": {
"id": 4,
"email": "testuser06@gmail.com",
"fullName": "Test06"
  },
"token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjQsImVtYWlsIjoidGVzdHVzZXIwNkBnbWFpbC5jb20iLCJpYXQiOjE3NjY0MDA5NTcsImV4cCI6MTc2NzAwNTc1N30.-y3EgS3ZJzfHHNo_8ylkUW_9nYJ3Hl6X14GkdKL8GY0"
  }
3.3.2 Управління тваринами
  1. Отримання списку тварин поточного користувача - /api/pets (GET)
Запит призначений для отримання списку всіх тварин, що належать поточному автентифікованому користувачу. Сервер виконує перевірку JWT-токена, визначає ідентифікатор користувача та повертає перелік тварин разом з їх основними характеристиками, такими як ім’я, тип їжі, рекомендована порція та наявність призначеного плану годування.
Приклад успішної відповіді:
  {
"ok": true,
"pets": [
{
"id": 7,
"userId": 4,
"name": "Laki",
"photoUrl": null,
"foodType": "Dry food",
"recommendedPortionGrams": 60,
"feedingPlanId": null
                                }
                    ]
  }
2. Створення нової тварини - /api/pets/add (POST)
Даний запит використовується для створення нової тварини в системі. Користувач передає основні дані тварини (ім’я, фото, тип їжі, рекомендовану порцію), після чого сервер перевіряє коректність даних, прив’язує створений запис до поточного користувача та зберігає його в базі даних.
Приклад запиту
  {
"name": "Laki",
"photoURL": "-",
"foodType": "Dry food",
"recommendedPortionGrams": "70"
  }
Приклад успішної відповіді:
{
"ok": true,
"pet": {
"id": 8,
"userId": 4,
"name": "Laki",
"photoUrl": null,
"foodType": "Dry food",
"recommendedPortionGrams": 70,
"feedingPlanId": null
                    }
}
3.  Видалення тварини - /api/pets/{petId} (DELETE)
Запит призначений для видалення тварини з системи. Сервер перевіряє, чи належить вказана тварина поточному користувачу, після чого видаляє відповідний запис з бази даних разом із пов’язаними даними (подіями годування, зв’язками з планами годування). Запит використовується у випадку, коли тварина більше не обслуговується в системі.
Приклад успішної відповіді:
  {
                    "ok": true
  }
4. Призначення плану годування тварині - /api/pets/{petId}/feeding-plan (POST)
Цей запит використовується для призначення або зміни плану годування для конкретної тварини. Користувач передає ідентифікатор плану годування, сервер перевіряє доступ користувача до обраного плану та оновлює зв’язок між твариною і планом у базі даних.
Приклад запиту:
  {
"feedingPlanId": 10
  }
Приклад успішної відповіді:
  {
                    "ok": true,
                    "pet": {
        "id": 7,
        "userId": 4,
        "name": "Laki",
        "photoUrl": null,
        "foodType": "Dry food",
                                "recommendedPortionGrams": 60,
                                "feedingPlanId": 10
}
  }
5. Отримання актуального розкладу годування для тварини - /api/pets/{petId}/schedules (GET)
Запит використовується для отримання актуального розкладу годування конкретної тварини. Сервер визначає тварину, перевіряє її належність користувачу та повертає розклад, сформований на основі призначеного плану годування з урахуванням активних записів та часу виконання.
Приклад успішної відповіді:
  {
    "ok": true,
    "schedules": [
        {
            "id": 11,
            "feedTime": "1970-01-01T06:00:00.000Z",
            "portionGrams": 13,
            "mode": "AUTO",
            "enabled": true
        },
        {
            "id": 12,
            "feedTime": "1970-01-01T13:00:00.000Z",
            "portionGrams": 13,
            "mode": "AUTO",
            "enabled": true
        },
        {
            "id": 13,
            "feedTime": "1970-01-01T20:00:00.000Z",
            "portionGrams": 13,
            "mode": "AUTO",
            "enabled": true
        }
]
  }


6. Отримання актуального розкладу годування для тварини - /api/pets/{petId}/rec-portion (POST)
Запит використовується для розрахунки та оновлення в таблиці рекомендованої порції в таблиці Pets.
Приклад успішної відповіді:
 {
"ok": true,
"message": "Рекомендовану порцію оновлено",
"data": {
                  "petId": 13,
                  "recommendedPortionGrams": {
                      "portion": 20,
                                      "typeUsed": "Dry"
                     }
 }
}




3.3.3 Плани та розклад годування
1. Створення нового плану годування - /api/feeding-plans/add (POST)
Запит використовується для створення нового плану годування. Користувач передає назву та опис плану, після чого сервер перевіряє автентифікацію користувача, створює запис плану, прив’язує його до власника та зберігає в базі даних. Створений план може надалі використовуватись для однієї або декількох тварин.
Приклад запиту:
  {
                    "name": "For Shpitz-terier",
                    "description": "Dry food, 3 times a day: Morning/Afternoon/Evening"
  }
Приклад успішної відповіді:
  {
                    "ok": true,
                    "plan": {
     "id": 11,
                              "userId": 4,
     "name": "For Shpitz-terier",
                                     "description": "Dry food, 3 times a day: Morning/Afternoon/Evening",
                  "createdAt": "2025-12-22T11:41:46.247Z"
                   }
  }
2. Отримання всіх планів користувача - /api/feeding-plans (GET)
Запит призначений для отримання списку всіх планів годування, створених поточним користувачем. Сервер ідентифікує користувача за JWT-токеном та повертає перелік планів з базовою інформацією (назва, опис, дата створення).
Приклад успішної відповіді:
  {
    "ok": true,
    "plans": [
                {
                    "id": 11,
            "userId": 4,
            "name": "For Shpitz-terier",
            "description": "Dry food, 3 times a day: Morning/Afternoon/Evening",
                                      "createdAt": "2025-12-22T11:41:46.247Z"
                },
                       {
          "id": 10,
                                    "userId": 4,
                                    "name": "For Laki",
          "description": "Dry food, 3 times a day: Morning/Afternoon/Evening ",
          "createdAt": "2025-12-22T11:27:45.477Z"
                       }
 ]
  }
3. Додавання записів розкладу до плану -  /api/feeding-plans/{planId}/schedules (POST)
Запит призначений для додавання одного або кількох записів розкладу до існуючого плану годування. Користувач передає параметри прийомів їжі (час, розмір порції, режим виконання), після чого сервер перевіряє належність плану користувачу та зберігає нові записи розкладу в базі даних.
Приклад запиту:
  {
    "feedTime": "20:00:00",
    "portionGrams": "13",
                    “mode”: AUTO
  }
Приклад успішної відповіді:
  {
    "id": 13,
    "feedTime": "1970-01-01T20:00:00.000Z",
    "portionGrams": 13,
    "mode": "AUTO",
    "enabled": true,
    "planId": 11
  }
3.3.4 Події годування
1. Створення події годування (автоматичної або ручної) - /api/events/add (POST)
Запит використовується для створення події годування тварини. Подія може бути ініційована автоматично системою (згідно з розкладом годування) або вручну користувачем. У запиті передається ідентифікатор тварини, розмір порції, тип ініціації (ручна або автоматична) та результат виконання. Сервер перевіряє права доступу користувача до тварини, зберігає подію з часовою міткою та фіксує факт годування в базі даних.
Приклад запиту:
  {
  "petId": 7,
  "deviceId": 2,
  "portionGrams": 13,
  "source": "AUTO",
  "result": "OK"
  }
Приклад успішної відповіді
  {
                    "message": "Feeding event created"
  }
2.  Отримання історії годувань конкретної тварини - /api/events/pet/{petId} (GET)
Запит призначений для отримання історії годувань конкретної тварини. Сервер перевіряє, чи належить тварина поточному користувачу, після чого повертає впорядкований список усіх подій годування, включаючи дату та час виконання, розмір порції, тип ініціації та результат.
Приклад успішної відповіді
  [
    {
                                "id": 16,
        "petId": 7,
        "deviceId": 2,
                                 "fedAt": "2025-12-22T15:34:22.209Z",
                                 "portionGrams": 13,
                                  "source": "MANUAL_APP",
        "result": "OK"
    },
    {
        "id": 14,
        "petId": 7,
        "deviceId": 2,
        "fedAt": "2025-12-22T15:28:40.922Z",
        "portionGrams": 13,
        "source": "AUTO",
        "result": "OK"
    }
]
3.3.5 Розклади годувань
1. Отримати розклади, прив’язані до планів годувань - /api/schedules/plans/{planId}(GET).
Запит використовується для отримання актуального розкладу годування конкретного плану. Сервер визначає план за допомогою айді, повертає розклад, сформований на основі призначеного плану годування з урахуванням активних записів та часу виконання.
Приклад успішної відповіді
{
  "ok": true,
  "schedules": [
    {
      "id": 18,
      "feedTime": "1970-01-01T09:45:00.000Z",
      "portionGrams": 65,
      "mode": "AUTO",
      "enabled": true,
      "planId": 13
    },
    {
      "id": 16,
      "feedTime": "1970-01-01T12:00:00.000Z",
      "portionGrams": 70,
      "mode": "AUTO",
      "enabled": true,
      "planId": 13
            }
                  ]
}
2. Додавання розкладу до планів годувань - /api/schedules/plans/{planId}(POST).
Запит використовується для додавання актуального розкладу годування до конкретного плану. 
Приклад запиту:
{
"feedTime": "21:00",
"portionGrams": 70
}
Приклад успішної відповіді
{
  "ok": true,
  "schedule": {
    "id": 19,
    "feedTime": "1970-01-01T21:00:00.000Z",
    "portionGrams": 70,
    "mode": "AUTO",
    "enabled": true,
    "planId": 13
 }
}
3. Додавання розкладу до планів годувань - /api/schedules/{scheduleId}(PATCH).
Запит використовується для оновлення актуального розкладу годування до конкретного плану. 
Приклад запиту:
{
  "feedTime": "21:45",
  "portionGrams": 65
}
Приклад успішної відповіді
{
  "ok": true,
  "message": "Розклад успішно оновлено",
  "data": {
    "id": 19,
    "feedTime": "1970-01-01T21:45:00.000Z",
    "portionGrams": 65,
    "mode": "AUTO",
    "enabled": true,
    "planId": 13
  }}
3.3.6 Керування пристроями користувача
1. Отримати розклади, прив’язані до планів годувань - /api/devices/add(POST).
Запит використовується для додавання нового пристрою у систему.
Приклад запиту:
{
          "serial": "QQQ1",
  "name": "feeder",
          "capacity": "3000"
}
Приклад успішної відповіді
{
  "ok": true,
  "device": {
    "id": 22,
    "userId": 10,
    "serial": "QQQ1",
    "name": "feeder",
    "capacity": "3000",
    "isConnected": false
  },
    "apiKey": "901d37a1b619916a0ca634467a0a23f1a70d8bb4a8897b85961686c5c7efc211"
}
2. Отримати розклади, прив’язані до планів годувань - /api/devices/connect(POST).
Запит використовується для підключення нового пристрою, для подальшої роботи та виконання запитів.
Приклад запиту:
{
  "name": "feeder",
  "serial": "QQQ1",
"apiKey": "901d37a1b619916a0ca634467a0a23f1a70d8bb4a8897b85961686c5c7efc211"
}
Приклад успішної відповіді
{
          "ok": true,
  "message": "Пристрій feeder успішно підключено!"
}
3. Отримати розклади, прив’язані до планів годувань - /api/devices/{deviceId}/refill(POST).
Запит використовується для поповнення рівня корму на пристрої.
Приклад запиту:
{
  "grams": 120
}
Приклад успішної відповіді
{
  "ok": true,
  "message": "Запас корму оновлено",
  "data": {
    "added": 120,
    "totalNow": 800,
    "percentNow": "80%"
  }
}
4. Отримати розклади, прив’язані до планів годувань - /api/schedules/pets/{petId}/feed-now(POST).
Запит використовується для годування тварини через кнопку на певному айді пристрою.
Приклад запиту:
{
  "deviceId": 16,
  "portionGrams": 50,
  "foodType": "Dry"
}
Приклад успішної відповіді
{
  "ok": true,
  "message": "Команда на годування відправлена",
  "event": {
    "id": 118,
    "petId": 13,
    "deviceId": 16,
    "portionGrams": 50,
    "foodType": "Dry",
    "source": "MANUAL_BUTTON",
    "result": "OK",
    "fedAt": "2026-01-12T01:35:01.220Z",
    "foodLevel": 750,
                            "foodLevelPercent": 75
  }
}
3.3.7 Адміністративні функції
1. Отримати список, усіх користувачів  - /api/admin/users(GET).
Запит використовується для отримання списку всіх користувачів, цей запит може використовувати лише адміністратор.
Приклад успішної відповіді
[
  {
    "id": 10,
    "email": "user@example.com",
    "fullName": "John Doe",
    "role": "admin",
    "createdAt": "2025-12-27T20:53:00.878Z"
  },
  {
    "id": 1,
    "email": "test1@mail.com",
    "fullName": "Test User",
    "role": "admin",
    "createdAt": "2025-12-15T13:19:53.872Z"
  }
]
2. Моніторинг усіх пристроїв у системі - /api/admin/users(GET).
Запит використовується для отримання списку всіх пристроїв, цей запит може використовувати лише адміністратор.
Приклад успішної відповіді
[
  {
    "id": 14,
    "name": "Kitchen feeder",
    "serial": "ABC-123456",
    "ownerEmail": "user@example.com",
    "lastSeenAt": "2025-12-28T19:24:02.253Z"
  },
  {
    "id": 22,
    "name": "feeder",
    "serial": "QQQ1",
    "ownerEmail": "user@example.com",
    "lastSeenAt": "2026-01-12T01:27:36.583Z"
  }
]
3. Отримання глобальної статистики системи- /api/admin/stats(GET).
Запит використовується для отримання статистики системи, цей запит може використовувати лише адміністратор. Приклад відповіді наведено в ДОДАТКУ Б.
3.3.8 Інші реалізовані функції


У системі також реалізовано ряд додаткових ендпоінтів для керування профілем, сповіщеннями та розширеного адміністрування:
* Оновлення профілю користувача (PATCH /api/auth/me) — дозволяє користувачу змінити своє ім'я або електронну пошту.
* Видалення власного профілю (DELETE /api/auth/me) — повне видалення облікового запису користувача з системи.
* Зміна ролі користувача (PATCH /api/admin/role) — адміністративна функція для надання або позбавлення прав адміністратора іншим користувачам див. рисунок Б.1.
* Отримання списку власних пристроїв (GET /api/devices) — повертає перелік усіх годівниць, прив'язаних до поточного користувача.
* Видалення пристрою (DELETE /api/devices/{id}) — відв'язує пристрій від облікового запису користувача.
* Отримання профілю годування для пристрою (GET /api/devices/{deviceId}/feeding-profile) — службовий запит, який використовує мікроконтролер (IoT) для синхронізації локальних налаштувань із сервером.
* Редагування даних тварини (PATCH /api/pets/{petId}) — оновлення інформації про тварину (вага, активність, фото) без створення нового запису.
* Отримання детальної інформації про план (GET /api/feeding-plans/{planId}) — перегляд конкретного плану годування за його ідентифікатором.
* Отримання списку сповіщень (GET /api/notifications/user) — перегляд історії системних повідомлень (наприклад, про низький рівень корму).


4 ВИСНОВКИ
У ході виконання роботи було успішно досягнуто основної мети щодо розробки та програмної реалізації бізнес-логіки і функцій адміністрування серверної частини інформаційної системи «Smart Pet Feeder». Використання платформи Node.js та багатошарової архітектури дозволило ефективно реалізувати складні алгоритми автоматичного розрахунку індивідуальних раціонів тварин на основі ветеринарних моделей та забезпечити надійну синхронізацію розкладів годування з IoT-пристроями в режимі реального часу. 
Окрім основного функціоналу, було створено повноцінний адміністративний модуль для глобального моніторингу стану системи та керування обліковими записами через рольову модель доступу, що разом із впровадженням захищеної автентифікації гарантує стабільність, безпеку та масштабованість розробленого програмного продукту.


5 ВИКОРИСТАНІ ДЖЕРЕЛА
1. JSON Web Token Introduction [Електронний ресурс]. – Режим доступу: https://jwt.io/introduction – Дата доступу: 21.12.2025.
2. Swagger (OpenAPI) Specification [Електронний ресурс]. – Режим доступу: https://swagger.io/specification/ – Дата доступу: 21.12.2025.
3. REST API Design Guide [Електронний ресурс]. – Режим доступу: https://restfulapi.net/ – Дата доступу: 21.12.2025.
4. WSAVA Global Nutrition Guidelines [Електронний ресурс]. – Режим доступу: https://wsava.org/global-guidelines/global-nutrition-guidelines/ – Дата доступу: 21.12.2025.














ДОДАТОК А
Відеозапис


Відеозапис доповіді: https://youtu.be/F7OCwUk9y-8


Хронологічний опис відеозапису:
00:00 - Вступ
00:23 - Авторизація
00:43 - Додавання тварини
00:55 - Розрахунок рекомендованої порції
01:42 - Створення плану годування
02:08 - Додавання розкладу годування
02:57 - Додавання пристрою
03:36 - Годування тварини
04:37 - Наповнення годівниці
05:17 - Функції адміністрування


























ДОДАТОК Б
Відповідь на запит отримання глобальної статистики системи
{
  "ok": true,
  "generatedAt": "2026-01-11T22:19:09.986Z",
  "overview": {
    "users": {
      "total": 5,
      "withPets": 3,
      "withoutPets": 2
    },
    "pets": {
      "total": 5,
      "averagePerUser": "1.0",
      "withActivePlans": 3
    }
  },
  "plansAndSchedules": {
    "totalPlans": 7,
    "adoptionRate": "60.0%"
  },
  "iotHealth": {
    "devices": {
      "total": 3,
      "onlineNow": 0,
      "onlineRate": "0.0%"
    }
  },
  "activity": {
    "totalFeedings": 99,
    "feedingsLast24h": 74,
    "successRate": "100.0%",
    "errorsCount": 0,
    "foodTypeDistribution": {
      "dry": 93,
      "wet": 6
    },
    "recentUsers": [
      {
        "email": "user@example.com",
        "createdAt": "2025-12-27T20:53:00.8782845"
      },
      {
        "email": "test3@mail.com",
        "createdAt": "2025-12-23T11:58:50.2281631"
      },
      {
        "email": "testuser06@gmail.com",
        "createdAt": "2025-12-22T10:24:43.7865403"
      },
      {
        "email": "test2@mail.com",
        "createdAt": "2025-12-15T14:22:54.7941655"
      },
      {
        "email": "test1@mail.com",
        "createdAt": "2025-12-15T13:19:53.8725244"
      }
    ]
  }
}
































ДОДАТОК В
  

Рисунок Б.1 - UML діаграма діяльності оновлення ролі користувача






  

Рисунок Б.2 - UML діаграма взаємодії (адміністратор)