МІНІСТЕРСТВО НАУКИ І ОСВІТИ УКРАЇНИ


ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ










Кафедра «Програмна інженерія»








ЗВІТ
з лабораторної роботи №2
 з дисципліни: «Аналіз та рефакторинг коду»
з теми: «Програмна система для автоматизації годування домашніх тварин»










 
Виконав:                                                                   Прийняв:
ст. гр. ПЗПІ-23-3                                                      ст. викл. каф. ПІ
Погорєлов М. І.                                                        Сокорчук Ігор Петрович




















Харків 2025
1. ІСТОРІЯ ЗМІН


№
	Дата
	Опис змін
	Версія звіту
	1
	10.12.2025
	початок роботи
	0.1
	2
	14.12.2025
	редагування попередньої версії
	1
	



2 ЗАВДАННЯ


Проєктування та реалізація серверної частини програмної системи з використанням реляційної бази даних і прикладного програмного інтерфейсу. У межах роботи необхідно розробити структуру серверної частини системи, побудувати UML-діаграму прецедентів та ER-діаграму даних, створити базу даних і діаграму її структури, а також реалізувати функції доступу до даних і REST API для взаємодії серверної частини з клієнтами. Завершальним етапом є перевірка коректності роботи серверного програмного коду та розміщення результатів у GitHub-репозиторії.




3 ОПИС ВИКОНАНОЇ РОБОТИ


3.1 Архітектурні рішення


Серверна частина програмної системи FeedMate реалізована за багатошаровою клієнт–серверною архітектурою з використанням REST API. В основі архітектури лежить поділ на логічні рівні: рівень маршрутизації (routes), рівень контролерів (controllers), рівень сервісної логіки (services) та рівень доступу до даних (repositories). Такий підхід забезпечує модульність, зручність розширення та спрощує супровід програмного коду.
Для взаємодії з клієнтською частиною використовується HTTP API у стилі REST, де кожен ресурс (користувачі, тварини, плани годування, розклади, події годування) має окремі маршрути та контролери. Аутентифікація користувачів реалізована за допомогою JWT-токенів, що передаються в заголовку Authorization, а доступ до захищених маршрутів контролюється middleware-компонентом авторизації.
Зберігання даних здійснюється у реляційній базі даних SQL Server, структура якої побудована на основі ER-діаграми з чітко визначеними зв’язками між таблицями (Users, Pets, Feeding_Plans, Feeding_Schedules, Feeding_Events). Доступ до бази даних реалізовано через окремий рівень репозиторіїв, що інкапсулює SQL-запити та ізолює бізнес-логіку від деталей роботи з БД.
 
3.2 Моделі та зв’язки між ними


У серверній частині програмної системи FeedMate використовується реляційна модель даних,Основними моделями бази даних є Users, Pets, Feeding_Plans, Feeding_Schedules, Devices та Feeding_Events. 
Модель Users зберігає інформацію про зареєстрованих користувачів системи (електронна пошта, хеш пароля, повне ім’я, дата створення). Один користувач може мати декілька тварин (Pets), декілька шаблонів планів годування (Feeding_Plans) та декілька IoT-пристроїв (Devices), що реалізує зв’язок один-до-багатьох.
Модель Pets представляє домашніх тварин користувача та містить інформацію про тип корму, рекомендовану порцію та прив’язаний план годування. Кожна тварина може бути пов’язана лише з одним планом годування, тому між таблицями Pets та Feeding_Plans реалізовано зв’язок багато-до-одного.
Модель Feeding_Plans використовується для збереження шаблонів планів годування, що належать конкретному користувачу. Кожен план складається з набору записів у таблиці Feeding_Schedules, які описують конкретні часові точки годування, об’єм порції, режим та активність розкладу. Таким чином між Feeding_Plans та Feeding_Schedules реалізовано зв’язок один-до-багатьох.
Модель Devices представляє фізичні IoT-пристрої (годівниці), які належать користувачеві. Кожен пристрій має унікальний серійний номер та ключ доступу, що використовується для автентифікації з серверною частиною системи. Дані про фактичні події годування зберігаються у таблиці Feeding_Events, яка пов’язана з конкретною твариною через зовнішній ключ, реалізуючи зв’язок один-до-багатьох.


3.3 UML діаграми прецедентів для серверної частини системи. 


Для опису функціональних можливостей серверної частини програмної системи FeedMate була розроблена UML-діаграма прецедентів. Діаграма відображає взаємодію зовнішніх акторів із сервером та основні сценарії використання, що реалізуються через прикладний програмний інтерфейс (API).
Актор User (користувач) представляє кінцевого користувача програмної системи, який взаємодіє із серверною частиною через клієнтський застосунок або веб-інтерфейс. Користувач має можливість виконувати реєстрацію та автентифікацію в системі, після чого отримує доступ до персоналізованих функцій керування.
Основними прецедентами для актора User є керування профілями домашніх тварин, створення, редагування та видалення розкладів годування, перегляд поточного розкладу годувань і історії вже виконаних годувань. Також користувач може переглядати системні сповіщення та нагадування, зокрема повідомлення про низький рівень корму або помилки пристрою. Окремим прецедентом є можливість ручного запуску годування («Feed Now»), який супроводжується фіксацією події годування в системі та подальшою синхронізацією даних із IoT-пристроєм.


  

Рисунок 3.1 - UML діаграма для User
Актор IoT Feeder представляє фізичний інтелектуальний пристрій годівниці, який автоматично взаємодіє із серверною частиною системи. Основним завданням цього актора є обмін технічною та подієвою інформацією з сервером для забезпечення коректного виконання розкладів годування.
IoT Feeder надсилає на сервер поточний статус пристрою, зокрема інформацію про рівень корму та стан працездатності. При виявленні критичних ситуацій, таких як низький рівень корму, пристрій ініціює створення відповідного сповіщення для користувача. Крім того, IoT Feeder отримує від сервера актуальний розклад годування та виконує синхронізацію цього розкладу. Усі факти виконаних годувань фіксуються пристроєм і передаються на сервер у вигляді подій годування.


  

Рисунок 3.2 - UML діаграма для IoT Feeder


3.4 ER діаграма
Сутність «Користувачі» (id_користувача, електронна_пошта, пароль, імʼя, дата_створення) зберігає облікові дані користувачів та є базовою сутністю системи. Один користувач може мати декілька тварин, планів годування, пристроїв і повідомлень. Сутність «Тварини» (id_тварини, id_користувача, імʼя_тварини, фото, тип_їжі, рекомендована_порція, id_плану_годування) описує домашніх тварин користувачів та пов’язана з користувачем і планом годування. Сутність «Плани годування» (id_плану_годування, id_користувача, назва, опис, дата_створення) зберігає шаблони режимів годування. Один план може бути призначений кільком тваринам. Сутність «Розклад годування» (id_розкладу_годування, id_плану_годування, час_годування, порція_в_грамах, режим, активний) визначає конкретні параметри прийомів їжі в межах плану годування. Сутність «Події годування» (id_події_годування, id_тварини, час_годування, порція_в_грамах, джерело, результат) фіксує фактичні випадки годування тварин. Сутність «Пристрої» (id_пристрою, id_користувача, серійний_номер, назва, ключ_доступу, остання_активність) описує IoT-годівниці, що належать користувачам. Сутність «Статус пристрою» (id_статусу_пристрою, id_пристрою, час_отримання, рівень_їжі, поточний_стан) зберігає історію станів пристрою. Сутність «Повідомлення» (id_повідомлення, id_користувача, час_створення, тип, текст, прочитано) використовується для інформування користувачів про події системи.


  

Рисунок 3.3 - ER діаграма


3.5 Схеми бази даних
На початковому етапі проєктування структура бази даних розглядалася у вигляді єдиного узагальненого відношення, яке об’єднувало інформацію про користувачів, їхніх тварин, плани та розклади годування, події годування, IoT-пристрої, їхній стан, а також системні повідомлення. У такій таблиці одночасно зберігалися різні ідентифікатори та атрибути, що логічно належать до різних сутностей. Усі поля містили неподільні (атомарні) значення, відсутні вкладені структури або повторювані групи даних, що відповідає вимогам першої нормальної форми.
  

Рисунок 3.4 - 1НФ
Під час переходу до другої нормальної форми було виявлено, що багато атрибутів залежать лише від окремих ідентифікаторів, а не від усього набору даних. Наприклад, характеристики користувача визначаються тільки його ідентифікатором, а параметри пристрою — лише ідентифікатором пристрою.
Для усунення таких залежностей структура була розділена на окремі таблиці за основними сутностями, зокрема користувачів, тварин та пристроїв. Основна таблиця перестала зберігати надлишкову інформацію й почала містити лише зовнішні ключі для зв’язку між відповідними сутностями. Це дозволило зменшити дублювання даних і зробити структуру логічно впорядкованою відповідно до вимог другої нормальної форми.


  

Рисунок 3.5 - 2НФ


На завершальному етапі нормалізації було усунено непрямі залежності між атрибутами, коли одні неключові поля визначалися через інші. Для цього додатково були виокремлені таблиці, що відповідають за логічно завершені процеси системи: плани годування, розклади прийомів їжі, події фактичного годування та повідомлення користувачів.
Кожна таблиця в остаточній структурі має власний первинний ключ, а всі її атрибути залежать виключно від нього. Зв’язки між таблицями реалізовані за допомогою зовнішніх ключів, що дозволяє коректно відображати взаємодію між користувачами, тваринами, планами та пристроями.
У результаті база даних була приведена до третьої нормальної форми, що забезпечує відсутність надлишкових даних, логічну цілісність та зручність подальшого розвитку серверної частини системи.




  

Рисунок 3.6 - 3НФ




3.6 Функції роботи з БД (CoRM)


У рамках CoRM-підходу моделі даних представлені у вигляді таблиць бази даних, а доступ до них реалізовано через окремі репозиторії з SQL-запитами. Кожна сутність системи (користувач, тварина, план годування, розклад, пристрій) має власний репозиторій, що забезпечує виконання CRUD-операцій. Зв’язки між моделями реалізовані за допомогою зовнішніх ключів у базі даних та JOIN-запитів у коді. Бізнес-логіка та перевірка прав доступу винесені до service-шару, що дозволяє чітко розділити відповідальність між компонентами системи.
Для роботи з базою даних у серверній частині системи використано підхід CoRM (Controller-oriented Relational Mapping), де взаємодія з БД реалізована через окремий шар репозиторіїв із SQL-запитами. Для кожної сутності системи створено набір функцій, що інкапсулюють доступ до даних.
Для сутності користувача використовуються функції createUser() – створення користувача, getUserByEmail() – пошук за email, getUserById() – отримання за ідентифікатором.
Для роботи з тваринами реалізовано listByUserId() – список тварин користувача, createPet() – створення тварини, deletePet() – видалення тварини, getById() – отримання тварини, getByIdForUser() – перевірка доступу, setFeedingPlan() – прив’язка плану годування.
Функції планів годування включають createPlan() – створення плану, listByUserId() – список планів, getById() – отримання плану, deletePlan() – видалення плану.
Робота з розкладом годування здійснюється через listByPlanId() – отримання розкладу, createSchedule() – додавання годування.
Події фактичного годування обробляються функціями createFeedingEvent() – фіксація події, listByPetId() – історія годувань.
Для IoT-пристроїв реалізовано registerDevice() – реєстрація пристрою, getDevicesByUser() – список пристроїв, updateDeviceStatus() – оновлення стану.
Система сповіщень використовує createNotification() – створення повідомлення, listByUserId() – отримання повідомлень, markAsRead() – позначення як прочитане.


3.7 Специфікація API
Для взаємодії клієнтських застосунків із серверною частиною програмної системи було розроблено RESTful API, побудоване на основі протоколу HTTP з використанням формату обміну даними JSON. API забезпечує доступ до основних функцій системи керування автоматизованим годуванням домашніх тварин.
Усі запити до захищених ресурсів виконуються з використанням JWT-аутентифікації. Після успішної автентифікації користувач отримує токен доступу, який передається у заголовку Authorization: Bearer <token>. 


3.7.1. Аутентифікація та користувачі 
1. Реєстрація користувача - api/auth/register (POST)
Запит використовується для створення нового облікового запису в системі. Користувач передає свої реєстраційні дані (електронну пошту, пароль, ім’я), які проходять валідацію на сервері. 
Приклад запиту:
  {
"email": "testuser06@gmail.com",
"password": "Testuser10",
"fullName": "Test06"
  }
Приклад успішної відповіді
  {
"ok": true,
 "user": {
 "id": 4,
                 "email": "testuser06@gmail.com",
"fullName": "Test06"
},
  }
2. Авторизація користувача - api/auth/login (POST)
Запит призначений для входу користувача в систему. Користувач надсилає електронну пошту та пароль, які перевіряються на відповідність збереженим у базі даних даним. У разі успішної автентифікації сервер генерує JWT-токен, який містить ідентифікатор користувача та використовується для доступу до захищених ресурсів API.
Приклад запиту:
  {
                    "email": "testuser06@gmail.com",
                    "password": "Testuser10"
  }
Приклад успішної  відповіді:
  {
"ok": true,
"user": {
"id": 4,
"email": "testuser06@gmail.com",
"fullName": "Test06"
  },
"token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjQsImVtYWlsIjoidGVzdHVzZXIwNkBnbWFpbC5jb20iLCJpYXQiOjE3NjY0MDA5NTcsImV4cCI6MTc2NzAwNTc1N30.-y3EgS3ZJzfHHNo_8ylkUW_9nYJ3Hl6X14GkdKL8GY0"
  }


3.7.2 Управління тваринами
  1. Отримання списку тварин поточного користувача - /api/pets (GET)
Запит призначений для отримання списку всіх тварин, що належать поточному автентифікованому користувачу. Сервер виконує перевірку JWT-токена, визначає ідентифікатор користувача та повертає перелік тварин разом з їх основними характеристиками, такими як ім’я, тип їжі, рекомендована порція та наявність призначеного плану годування.
Приклад успішної відповіді:
  {
"ok": true,
"pets": [
{
"id": 7,
"userId": 4,
"name": "Laki",
"photoUrl": null,
"foodType": "Dry food",
"recommendedPortionGrams": 60,
"feedingPlanId": null
                                }
                    ]
  }
2. Створення нової тварини - /api/pets/add (POST)
Даний запит використовується для створення нової тварини в системі. Користувач передає основні дані тварини (ім’я, фото, тип їжі, рекомендовану порцію), після чого сервер перевіряє коректність даних, прив’язує створений запис до поточного користувача та зберігає його в базі даних.
Приклад запиту
  {
"name": "Laki",
"photoURL": "-",
"foodType": "Dry food",
"recommendedPortionGrams": "70"
  }
Приклад успішної відповіді:
{
"ok": true,
"pet": {
"id": 8,
"userId": 4,
"name": "Laki",
"photoUrl": null,
"foodType": "Dry food",
"recommendedPortionGrams": 70,
"feedingPlanId": null
                    }
}
3.  Видалення тварини - /api/pets/{petId} (DELETE)
Запит призначений для видалення тварини з системи. Сервер перевіряє, чи належить вказана тварина поточному користувачу, після чого видаляє відповідний запис з бази даних разом із пов’язаними даними (подіями годування, зв’язками з планами годування). Запит використовується у випадку, коли тварина більше не обслуговується в системі.
Приклад успішної відповіді:
  {
                    "ok": true
  }
4. Призначення плану годування тварині - /api/pets/{petId}/feeding-plan (POST)
Цей запит використовується для призначення або зміни плану годування для конкретної тварини. Користувач передає ідентифікатор плану годування, сервер перевіряє доступ користувача до обраного плану та оновлює зв’язок між твариною і планом у базі даних.
Приклад запиту:
  {
"feedingPlanId": 10
  }
Приклад успішної відповіді:
  {
                    "ok": true,
                    "pet": {
        "id": 7,
        "userId": 4,
        "name": "Laki",
        "photoUrl": null,
        "foodType": "Dry food",
                                "recommendedPortionGrams": 60,
                                "feedingPlanId": 10
}
  }


3.7.3 Плани та розклад годування
1. Створення нового плану годування - /api/feeding-plans/add (POST)
Запит використовується для створення нового плану годування. Користувач передає назву та опис плану, після чого сервер перевіряє автентифікацію користувача, створює запис плану, прив’язує його до власника та зберігає в базі даних. Створений план може надалі використовуватись для однієї або декількох тварин.
Приклад запиту:
  {
                    "name": "For Shpitz-terier",
                    "description": "Dry food, 3 times a day: Morning/Afternoon/Evening"
  }
Приклад успішної відповіді:
  {
                    "ok": true,
                    "plan": {
     "id": 11,
                              "userId": 4,
     "name": "For Shpitz-terier",
                                     "description": "Dry food, 3 times a day: Morning/Afternoon/Evening",
                  "createdAt": "2025-12-22T11:41:46.247Z"
                   }
  }
2. Отримання всіх планів користувача - /api/feeding-plans (GET)
Запит призначений для отримання списку всіх планів годування, створених поточним користувачем. Сервер ідентифікує користувача за JWT-токеном та повертає перелік планів з базовою інформацією (назва, опис, дата створення).
Приклад успішної відповіді:
  {
    "ok": true,
    "plans": [
                {
                    "id": 11,
            "userId": 4,
            "name": "For Shpitz-terier",
            "description": "Dry food, 3 times a day: Morning/Afternoon/Evening",
                                      "createdAt": "2025-12-22T11:41:46.247Z"
                },
                       {
          "id": 10,
                                    "userId": 4,
                                    "name": "For Laki",
          "description": "Dry food, 3 times a day: Morning/Afternoon/Evening ",
          "createdAt": "2025-12-22T11:27:45.477Z"
                       }
 ]
  }
3. Додавання записів розкладу до плану -  /api/feeding-plans/{planId}/schedules (POST)
Запит призначений для додавання одного або кількох записів розкладу до існуючого плану годування. Користувач передає параметри прийомів їжі (час, розмір порції, режим виконання), після чого сервер перевіряє належність плану користувачу та зберігає нові записи розкладу в базі даних.
Приклад запиту:
  {
    "feedTime": "20:00:00",
    "portionGrams": "13",
                    “mode”: AUTO
  }
Приклад успішної відповіді:
  {
    "id": 13,
    "feedTime": "1970-01-01T20:00:00.000Z",
    "portionGrams": 13,
    "mode": "AUTO",
    "enabled": true,
    "planId": 11
  }
4. Отримання актуального розкладу годування для тварини - /api/pets/{petId}/schedules (GET)
Pапит використовується для отримання актуального розкладу годування конкретної тварини. Сервер визначає тварину, перевіряє її належність користувачу та повертає розклад, сформований на основі призначеного плану годування з урахуванням активних записів та часу виконання.
Приклад успішної відповіді:
  {
    "ok": true,
    "schedules": [
        {
            "id": 11,
            "feedTime": "1970-01-01T06:00:00.000Z",
            "portionGrams": 13,
            "mode": "AUTO",
            "enabled": true
        },
        {
            "id": 12,
            "feedTime": "1970-01-01T13:00:00.000Z",
            "portionGrams": 13,
            "mode": "AUTO",
            "enabled": true
        },
        {
            "id": 13,
            "feedTime": "1970-01-01T20:00:00.000Z",
            "portionGrams": 13,
            "mode": "AUTO",
            "enabled": true
        }
]
  }


3.7.4 Події годування
1. Створення події годування (автоматичної або ручної) - /api/events/add (POST)
Запит використовується для створення події годування тварини. Подія може бути ініційована автоматично системою (згідно з розкладом годування) або вручну користувачем. У запиті передається ідентифікатор тварини, розмір порції, тип ініціації (ручна або автоматична) та результат виконання. Сервер перевіряє права доступу користувача до тварини, зберігає подію з часовою міткою та фіксує факт годування в базі даних.
Приклад запиту:
  {
  "petId": 7,
  "deviceId": 2,
  "portionGrams": 13,
  "source": "AUTO",
  "result": "OK"
  }
Приклад успішної відповіді
  {
                    "message": "Feeding event created"
  }
2.  Отримання історії годувань конкретної тварини - /api/events/pet/{petId} (GET)
Запит призначений для отримання історії годувань конкретної тварини. Сервер перевіряє, чи належить тварина поточному користувачу, після чого повертає впорядкований список усіх подій годування, включаючи дату та час виконання, розмір порції, тип ініціації та результат.
Приклад успішної відповіді
  [
    {
                                "id": 16,
        "petId": 7,
        "deviceId": 2,
                                 "fedAt": "2025-12-22T15:34:22.209Z",
                                 "portionGrams": 13,
                                  "source": "MANUAL_APP",
        "result": "OK"
    },
    {
        "id": 14,
        "petId": 7,
        "deviceId": 2,
        "fedAt": "2025-12-22T15:28:40.922Z",
        "portionGrams": 13,
        "source": "AUTO",
        "result": "OK"
    }
]


3.7.5 Обробка помилок (Error Handling)
1. Помилки авторизації (401 Unauthorized)
Виникає, якщо в заголовку запиту (Headers) відсутній або недійсний токен доступу (Authorization: Bearer <token>).
Приклад відповіді:
          {
  "error": "Unauthorized Access",
  "message": "No token provided or token expired"
  }
2. Помилка доступу або відсутності ресурсу (404 Not Found)
Виникає, коли вказаний petId не існує в базі даних або ця тварина не належить поточному користувачу. Це критично для безпеки, щоб користувач не міг бачити історію чужих улюбленців.
Приклад відповіді:
          {
  "message": "Pet not found or access denied"
  }


3. Помилка валідації даних (400 Bad Request)
Виникає, якщо тіло запиту (JSON) містить некоректні дані, наприклад:
* portionGrams є від'ємним числом або нулем.
* Відсутнє обов'язкове поле (наприклад, source).
* Передано невірний тип даних (рядок замість числа).
Приклад відповіді:
          {
  "error": "Validation Error",
  "message": "Portion grams must be a positive number"
  }
4. Помилка бізнес-логіки / Конфлікт (409 Conflict)
Виникає у випадку конфлікту з налаштуваннями бази даних, наприклад, спроба відправити команду на пристрій (deviceId), який наразі офлайн або не прикріплений до цієї тварини.
Приклад відповіді:
          {
  "message": "Device is not assigned to this pet"
  }
5. Системна помилка (500 Internal Server Error)
Виникає при неочікуваних проблемах на сервері: збій з'єднання з базою даних SQL Server або помилка в коді.
Приклад відповіді:
          {
  "error": "Internal Server Error",
  "message": "An unexpected error occurred on the server"
  }








4 ВИСНОВКИ
У ході виконання роботи було спроєктовано та реалізовано серверну частину системи FeedMate на стеку Node.js та SQL Server. Фактично побудовано реляційну базу даних у 3НФ, що забезпечило цілісність зв’язків між користувачами, тваринами та IoT-пристроями. Розроблено REST API із розмежуванням доступу: впроваджено JWT-автентифікацію для клієнтських додатків та систему API Key для ідентифікації обладнання.
Програмна логіка реалізована за архітектурним шаблоном Controller-Service-Repository, що дозволило відокремити SQL-запити від бізнес-правил. Система забезпечує автоматичну фіксацію історії годувань у таблиці FEEDING_EVENTS із валідацією прав доступу власника до конкретної тварини. Побудована архітектура створює стабільну основу для подальшого впровадження черги команд та повноцінної інтеграції з IoT-модулями на базі ESP32.














































5 ВИКОРИСТАНІ ДЖЕРЕЛА


1. Express web framework (Node.js/JavaScript). Expressjs.com. URL: https://expressjs.com/ (дата звернення: 22.12.2025). — Офіційна документація фреймворку для побудови RESTful API.
2. Microsoft SQL Server Documentation. Microsoft Learn. URL: https://learn.microsoft.com/en-us/sql/sql-server/ (дата звернення: 22.12.2025). — Керівництво з проєктування та управління реляційними базами даних.
3. JSON Web Token (JWT) Introduction. Auth0. URL: https://jwt.io/introduction/ (дата звернення: 22.12.2025). — Стандарт безпечної передачі даних між сервером та клієнтом для автентифікації.
4. Node-MSSQL (Microsoft SQL Server client for Node.js). GitHub. URL: https://github.com/tediousjs/node-mssql (дата звернення: 22.12.2025). — Документація бібліотеки для інтеграції Node.js із базою даних SQL Server.












































ДОДАТОК А
Відеозапис
Відеозапис доповіді: https://youtu.be/zOq017FMbQc
00:00 - Вступ
00:21 - Архітектурні рішення
01:25 - UML-діаграма
02:25 - ER-діаграма
03:12 - Схема бази даних
04:32 - 3НФ
04:54 - Функції роботи з БД (CoRM)
06:54 - Специфікація API
07:27 - Тестування