МІНІСТЕРСТВО НАУКИ І ОСВІТИ УКРАЇНИ


ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ










Кафедра «Програмна інженерія»








ЗВІТ
з практичної роботи №1
 з дисципліни: «Аналіз та рефакторинг коду»
з теми: «Правила оформлення Python-коду для веб-розробки y Django»










 
Виконав:                                                                   Прийняв:
ст. гр. ПЗПІ-23-3                                                      ст. викл. каф. ПІ
Погорєлов М. І.                                                        Сокорчук Ігор Петрович




















Харків 2025
1 ПРАВИЛА ОФОРМЛЕННЯ PYTHON-КОДУ ДЛЯ ВЕБ-РОЗРОБКИ У DJANGO
1.1 Вступ
У сучасній розробці програмного забезпечення, особливо в командних проєктах, стиль оформлення коду має не менше значення, ніж сам алгоритм. Від того, наскільки код читабельний, структурований та уніфікований, залежить швидкість розуміння логіки, простота внесення змін і кількість помилок, що виникають під час підтримки та розширення проєкту.
Фреймворк Django є потужним інструментом для веб-розробки на мові Python, який дозволяє швидко створювати надійні та масштабовані веб-сайти. Використання Django передбачає дотримання певних правил оформлення коду, зокрема рекомендацій PEP 8, а також спеціалізованих стилістичних підходів до структурування моделей, представлень (views), URL-маршрутів і шаблонів. Це підвищує читабельність коду, спрощує аналіз логіки, забезпечує однаковий стиль роботи всієї команди, зменшує кількість помилок і прискорює рефакторинг.
Метою цієї роботи є систематизація основних правил оформлення коду на прикладі Python та Django, розгляд типових конвенцій стилю, інструментів контролю якості коду, а також демонстрація практичних прикладів правильного і неправильного оформлення.
1.2 Значення стандартизації коду для команди розробників
1.2.1 Роль стандартизації в командній розробці
Стандартизація коду відіграє ключову роль у командних проєктах, оскільки дозволяє усім учасникам працювати в єдиному стилі. Завдяки цьому код різних розробників виглядає однаково структуровано, що суттєво полегшує спільну роботу, прискорює перевірку та мінімізує кількість непорозумінь. У Django-проєктах, де кожен застосунок містить моделі, представлення, сервіси й шаблони, стандартизований стиль допомагає підтримувати загальну логіку побудови системи.
1.2.2 Вплив на якість і підтримуваність програмного забезпечення
Чіткі правила оформлення коду підвищують якість програмного продукту. Стандартизована структура дозволяє легко аналізувати логіку, знаходити помилки та оптимізувати окремі компоненти. Підтримка проєкту стає дешевшою та ефективнішою, адже читання й розуміння коду не потребує додаткових пояснень від автора.
1.2.3 Спрощення процесів навчання та адаптації
Нові учасники команди швидко включаються в роботу, якщо проект оформлений згідно з усталеними правилами — PEP8, Django Style Guide і внутрішніми стандартами команди. Уніфікованість знижує поріг входу й допомагає уникати типових помилок.
1.3 Структура коду
1.3.1 Організація проєкту та файлової структури
У Django структура проєкту має визначальне значення для логічності й підтримуваності коду. Стандартна архітектура складається з "проєкту" (project) та одного або кількох "застосунків" (apps). Кожен застосунок реалізує певну частину функціоналу, а чіткий поділ обов’язків дозволяє уникнути змішування логіки та запобігає дублюванню.
  

Рис 1.1 - Стандартна структура Django-проєкту


Директорія “shop/” – окремий Django-додаток (app), що відповідає за роботу магазину: зберігання інформації про товари, замовлення, кошик, обробку запитів користувача тощо..
Файл “models.py” містить моделі бази даних, описані за допомогою Django ORM. Тут визначаються сутності, на приклад: “Product”, “Order”, “OrderItem”, їх поля, зв’язки між ними та базові методи. Саме на основі цих моделей Django створює таблиці у базі даних.
Файл “views.py” включає view-функції або класові представлення, які обробляють HTTP-запити. Кожне представлення отримує дані від користувача, звертається до моделей або сервісів, формує контекст і повертає HTTP-відповідь.
Файл “urls.py” відповідає за маршрутизацію в межах додатку. У ньому налаштовується відповідність між шляхами та конкретними views. Завдяки цьому при зверненні користувача за URL Django знає, яку функцію або клас викликати.
Директорія “services/” використовується як шар бізнес-логіки. Тут розміщуються функції та класи, що виконують обчислення й операції, які не мають напряму відноситися ні до моделей, ні до представлень.
* Файл “order_service.py” є окремим сервісним модулем, у якому може бути зосереджена логіка, пов’язана з обробкою замовлень.
Директорія templates/ містить HTML-шаблони, які використовуються для формування сторінок, що повертаються користувачу.
* Підкаталог “templates/shop/” призначений для шаблонів, що відносяться саме до додатку shop. Такий поділ полегшує навігацію та дозволяє мати шаблони з однаковими назвами в різних додатках.
* Файл “order_list.html” – це шаблон для відображення списку замовлень. Він отримує з view контекст (наприклад, список замовлень orders і загальну суму total) та показує їх користувачеві у вигляді HTML-сторінки. 
1.4 Форматування коду
1.4.1 Відступи, вирівнювання та довжина рядків
Одним із ключових принципів оформлення Python-коду є дотримання єдиних відступів та логічного вирівнювання. Python використовує відступи не лише для візуальної структури, але й для визначення блоків коду, тому порушення правил форматування може призвести до синтаксичних помилок. Основні правила:
* стандартний відступ — 4 пробіли;
* заборонено змішувати пробіли та табуляцію;
* максимальна рекомендована довжина рядка — 79 символів (PEP 8);
* при перенесенні довгих виразів параметри мають бути вирівняні логічно та читабельно.
/Java/
# Поганий приклад
Order order=createOrder(user,cartItems,true);


-немає пробілів навколо операторів “=” та “,”;
-рядок занадто щільний і важко читається;
-аргументи змішані в один рядок — погано для довгих викликів;
-відсутнє логічне форматування;
-важко підтримувати та додавати нові параметри.


/Java/
# Гарний приклад
order = create_order(
    user=request.user,
    items=cart_items,
    apply_discount=True,
)


- логічне вирівнювання аргументів;
-чіткі назви змінних (“user”, “cartItems”);
-кожен аргумент — на окремому рядку, структура читабельна;
-закриваюча дужка вирівняна з початком виклику функції;
-стиль відповідає Java Code Conventions.
1.4.2 Табуляція чи пробіли
У Python дозволяється лише один підхід — використання пробілів, а саме:
* 4 пробіли = один рівень вкладеності;
* табуляція не застосовується, оскільки її різна інтерпретація у 
* редакторах може спричинити помилки;
* сучасні редактори (VS Code, PyCharm) мають автоматичну конвертацію табів у пробіли.
/Java/
# Поганий приклад
def create_order(user, items):
    if user.is_authenticated:
    →   total = 0      # ← табуляція використана замість пробілів
        for item in items:
            total += item.price
        return total


-вкладений рядок має табуляцію замість 4 пробілів;
-відступи в блоці if стають «плаваючими», Python може під час виконання видати помилку: “IndentationError: inconsistent use of tabs and spaces;”


# Гарний приклад
def create_order(user, items):
    if user.is_authenticated:
        total = 0      # ← 4 пробіли
        for item in items:
            total += item.price
        return total


-усі рівні вкладеності створені 4 пробілами, відповідно до PEP 8;
-логіка легко читається;
-код не викликає помилок через змішані відступи;
-виглядає професійно та послідовно.


1.4.3 Стандарти для дужок та блоків коду
Правильне використання дужок та оформлення блоків коду має важливе значення для підвищення читабельності та уникнення помилок. У Python форматування дужок і структури блоків базується на принципах, подібних до K&R-стилю, але з урахуванням особливостей самої мови. Основні правила оформлення дужок у Python:
* Відкриваюча дужка ((, [, {) ставиться в тому ж рядку, де починається конструкція.
* Закриваюча дужка розміщується на новому рядку і вирівнюється по першому символу конструкції, що відкриває вираз.
* Довгі колекції, аргументи функцій або складні умови переноситься вертикально, щоб кожен елемент займав окремий рядок.
* Логічне групування виразів досягається за рахунок переносу рядків і зрозумілого відступу.
* Крапка з комою (;) не використовується — кожен оператор має знаходитися на окремому рядку.

/Java/
# Поганий приклад
products = ["Laptop","Monitor","Mouse",
"Keyboard","Headphones"]
def filter_orders(orders): 
  return [o for o in orders if o.total>100 and o.status=="confirmed"]
-елементи списку розташовані в одному рядку → важко читати;
-порушено вирівнювання елементів у списку;
-у другій функції неправильний відступ (2 пробіли замість 4);
-складний list comprehension у один рядок — погана читабельність;
-логічні частини виразу (o.total > 100 та o.status == "confirmed") злиті разом.



/Java/
# Гарний приклад
products = [
    "Laptop",
    "Monitor",
    "Mouse",
    "Keyboard",
    "Headphones",
]


def filter_orders(orders):
    return [
        order
        for order in orders
        if (
            order.total > 100
            and order.status == "confirmed"
        )
    ]
-кожен елемент колекції знаходиться на окремому рядку → читабельно;
-дужки відкриті та закриті за правилами PEP 8;
-list comprehension структурований вертикально;
-логічні умови згруповані та перенесені з вирівнюванням;
-відступи — строго 4 пробіли;
-код легко зрозуміти та підтримувати.
1.4.4 Іменування
Правильне іменування відіграє ключову роль у структурі та читабельності Python- та Django-проєктів. Стандарти іменування, описані в PEP 8, забезпечують зрозумілу організацію коду й дозволяють легко розрізняти класи, методи, змінні та модулі.Основні правила іменування:
   * Імена класів: використовують стиль CamelCase
OrderService, UserProfile, ProductDetailView
   * Імена функцій, методів, маршрутів і змінних: snake_case
create_order(), calculate_total_price(), order_list_view
   * Константи: великі літери з підкресленнями
MAX_ITEMS, DEFAULT_CURRENCY
   * Модулі та файли: snake_case
order_service.py, user_utils.py
   * Шаблони Django (HTML): короткі, змістовні назви
order_list.html, product_detail.html

/Java/
# Поганий приклад
class userprofile:
    def CreateOrder(self, ItemsList, DiscountRate):
        TotalPrice = 0
        for Item in ItemsList:
            TotalPrice += Item.price
        return TotalPrice


-ім’я класу userprofile не відповідає CamelCase;
-метод CreateOrder написаний у PascalCase → порушення PEP 8;
назви змінних ItemsList, Item, TotalPrice у CamelCase → неправильно для Python;
-незрозуміло, що робить метод — немає докстрінгу;
-логіка методу не оформлена як бізнес-функція (порушення Django best practices).

/Java/
# Гарний приклад
class UserProfile:
    def create_order(self, items_list, discount_rate):
        total_price = 0
        for item in items_list:
            total_price += item.price
        return total_price


-клас UserProfile відповідає CamelCase;
-метод create_order — у snake_case;
-змінні items_list, total_price, item — змістовні та у правильному стилі;
-код легко читати й розуміти;
-структура відповідає стандартам PEP 8 і Django.
1.4.5 Коментарі
Коментарі — важлива частина чистого коду, але вони мають використовуватися правильно. Основне правило: коментар має пояснювати “чому”, а не “що робить код”.
Коментарі слід застосовувати для:
      * пояснення складних або неочевидних рішень;
      * опису бізнес-логіки;
      * попередження про побічні ефекти;
      * розділення великих файлів на логічні секції.
/Java/
# Поганий приклад
# додаємо 1
counter = counter + 1


# цикл перебирає список
for item in items:
    print(item)


-коментарі дублюють очевидний код;
-немає пояснення, навіщо це робиться;
-зайві коментарі погіршують читабельність.

/Java/
# Гарний приклад
# лічильник зберігає кількість успішно оброблених записів,
# тому інкрементуємо його після кожної валідної операції
processed_count += 1


# виводимо елементи у тому порядку, у якому користувач додав їх у кошик
for item in items:
    print(item)


-коментар пояснює чому виконується операція;
-дається контекст бізнес-логіки;
-коментар допомагає зрозуміти поведінку, яку не видно з самого коду.
1.4.6 Документація коду
Докстрінги (docstrings) — це вбудований механізм документування Python-коду. Вони описують призначення класів, функцій та методів, не дублюючи їх реалізацію. Правильно оформлений докстрінг повинен:
      * коротко пояснювати призначення функції/класу;
      * описувати параметри (type hints або текстом);
      * описувати значення, яке повертається;
      * пояснювати можливі винятки (raise);
      * не дублювати внутрішню логіку коду.


/Java/
# Поганий приклад
def calculate_total(price, tax):
    """
    Функція рахує total.
    """
    return price + tax


-опис занадто короткий;
-не зазначено параметри;
-не пояснено логіку;
-слово “total” нічого не пояснює;
-докстрінг просто переповідає назву.


/Java/
# Гарний приклад
def calculate_total(price: float, tax_rate: float) -> float:
    """
    Обчислює фінальну вартість товару з урахуванням податкової ставки.


    :param price: базова ціна товару
    :param tax_rate: ставка податку у вигляді десяткового дробу (наприклад, 0.2)
    :return: кінцева вартість з урахуванням податку
    """
    return price * (1 + tax_rate)


-докстрінг описує призначення, а не повторює код;
-усі параметри задокументовано;
-структура відповідає загальноприйнятим стандартам;
-читач може зрозуміти логіку не читаючи сам код.


1.4.7 Імпорти 
Правильна організація імпортів — важлива частина стандартизації Python-коду. Чітко структуровані імпорти роблять файл читабельнішим, дозволяють швидше орієнтуватися в залежностях та спрощують підтримку. PEP 8 та Django Style Guide визначають конкретний порядок і правила імпортування.
Основні правила оформлення імпортів:
1. Імпорти групуються у 4 блоки (у строгій послідовності):
      1. Стандартна бібліотека Python
(os, sys, datetime, pathlib)
      2. Сторонні пакети (third-party)
(requests, rest_framework, numpy)
      3. Django-бібліотеки
(from django.db import models, from django.http import HttpRequest)
      4. Локальні модулі проєкту
(from app.services.order_service import calculate_total)
2. Між кожною групою — порожній рядок
Це допомагає візуально розділяти типи імпортів.
3. Заборонено використовувати from module import *
         * погіршує читабельність;
         * ускладнює пошук джерела функцій/класів;
         * може призвести до конфліктів імен.
4. Слід використовувати абсолютні імпорти, а не відносні
Абсолютні імпорти краще читаються та чіткіше відображають структуру проєкту.


/Java/
# Поганий приклад
from .service import calculate
import django
import os, sys
from django.db import models
from django.http import HttpRequest
from app.services.order_service import calculate_total


-перший імпорт — відносний → не рекомендовано;
-імпорти стандартної бібліотеки (os, sys) змішані в один рядок;
-порядок імпортів переплутаний (Django змішаний із third-party);
-між групами немає порожніх рядків;
-імпорт Django (import django) не потрібен у більшості випадків;
-немає логічного розділення за типом пакетів.


/Java/
# Гарний приклад
import os
import sys


import requests


from django.db import models
from django.http import HttpRequest


from app.services.order_service import calculate_total


-імпорти чітко розділені на групи;
-кожна група відокремлена порожнім рядком;
-стандартні бібліотеки — першими;
-сторонні пакети — другим блоком;
-Django-імпорти — окремо;
-локальні модулі — останні;
-використано абсолютний шлях імпорту;
-красиво, структуровано, повністю відповідає PEP 8.
1.5 Оформлення функцій у Django
Правильне оформлення функцій у Django є критично важливим для підтримуваності проєкту, якості коду та зручності командної розробки. Django пропонує високий рівень структурованості, тому функції — як у view, так і в сервісних модулях — мають бути максимально зрозумілими, послідовними й простими.
1.5.1 Основні принципи оформлення функцій
1. Чіткість і стислість
Функція повинна виконувати одну чітку дію. У Django це особливо важливо: view не повинні містити бізнес-логіки, а лише викликати відповідні сервіси.
2. Змістовні назви
Назва функції має чітко відображати її призначення:
         * get_order_by_id()
         * calculate_total_price()
         * send_notification_email()
Уникати абстрактних імен на кшталт data(), handle(), process().
3. Єдині шаблони
Подібні за змістом функції мають оформлюватися однаково:
         * однаковий порядок параметрів;
         * однакове форматування;
         * той самий стиль назв (get_…, create_…, update_…).
4. snake_case — для функцій, PascalCase — лише для класів
Згідно з PEP 8:
         * функції та методи → snake_case
         * класи → PascalCase
Це дозволяє легко відрізняти класи від функцій.
/Java/
# Поганий приклад
# Ім'я не описує дію, логіка у view, відсутні типи
def data(request, id):
    order = Order.objects.get(pk=id)
    order.total = order.price * order.quantity
    return order


-назва data не дає зрозуміти, що функція робить;
-бізнес-логіка (order.total = ...) виконується прямо у view → порушення Django-патернів;
-немає type hints;
-відсутній докстрінг;
-не обробляються помилки (DoesNotExist);
-view повертає об'єкт моделі, а не HTTP-відповідь


/Java/
# Гарний приклад
# Чітка назва, логіка винесена у service, використано type hints
def get_order_by_id(order_id: int) -> Order:
    return Order.objects.get(id=order_id)


# View лише викликає сервіс і повертає дані
def order_detail_view(request, order_id: int):
    order = get_order_by_id(order_id)
    return render(request, "shop/order_detail.html", {"order": order})


-назва get_order_by_id чітко описує дію;
-view мінімалістичне та викликає окрему бізнес-функцію;
-логіка не дублюється;
-використані type hints (order_id: int);
-view повертає HTTP-відповідь, як і повинно бути у Django;
-функції легко тестувати та супроводжувати.
1.6 Оформлення моделей у Django
Моделі Django — це центральний елемент роботи з даними, і правильна організація їх структури має критичне значення для цілісності проєкту. Якісно оформлена модель повинна бути зрозумілою, легко читабельною та відповідати одній конкретній сутності бізнес-логіки.
1.6.1 Основні стандарти оформлення моделей
1. Кожна модель описує одну сутність
Модель повинна відображати одну таблицю / одну логічну одиницю, наприклад:
         * Order — замовлення користувача
         * Product — товар
         * UserProfile — профіль
Недопустимо змішувати непов’язані поля в одному класі.
2. Поля групуються логічно та вирівнюються
Поля розташовують блоками:
         * ключові зв’язки (ForeignKey, OneToOneField)
         * числові значення
         * текстові поля
         * службові поля (created_at, updated_at)
Це покращує читабельність моделі.


3. Метод __str__() — обов’язковий
Він визначає, як об’єкт буде відображатися в адмінці, логах та спискових поданнях.


4. У class Meta: зберігаються лише службові налаштування
Наприклад:
         * сортування (ordering)
         * назва таблиці (db_table)
         * унікальні обмеження (unique_together)
До Meta не допускається розміщення логіки.


5. Бізнес-логіку НЕ розміщують у моделях
Моделі — це структура даних, а не місце для розрахунків чи складних операцій.  Бізнес-функції повинні бути у шарах:
         * services/
         * utils/
         * managers/ (у складних проєктах, але не у моделях)

/Java/
# Поганий приклад
class Order(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    price = models.FloatField()
    quantity = models.IntegerField()
    created = models.DateTimeField(auto_now_add=True)


    # Бізнес-логіка всередині моделі — порушення!     
    def calculate_total(self):
        return self.price * self.quantity * 0.95  # магічне число


    def __unicode__(self):
        return self.id   # неправильний формат стрінги


    class Meta:
        # логіка в Meta — теж порушення
        if price > 100:
            discount = True


-логіка розрахунку (calculate_total) прямо в моделі;
-використано магічне число 0.95;
-метод __unicode__ замість __str__;
-повертається число, а не зрозумілий текст;
-у Meta присутня логіка → грубе порушення Django-практик;
-назви полів не згруповані;
-не використано created_at, updated_at, які є стандартом у Django.

/Java/
# Гарний приклад
class Order(models.Model):
    """
    Модель замовлення. Зберігає посилання на користувача,
    загальну суму та дату створення.
    """


    user = models.ForeignKey(User, on_delete=models.CASCADE)
    total = models.DecimalField(max_digits=10, decimal_places=2)
    created_at = models.DateTimeField(auto_now_add=True)


    def __str__(self) -> str:
        return f"Order #{self.id}"


    class Meta:
        ordering = ["-created_at"]
-модель описує лише одну сутність — замовлення;
-назви полів структуровані та вирівняні;
-використовуються коректні типи полів (DecimalField замість FloatField);
-метод __str__() повертає зрозумілий текст;
-службові налаштування (ordering) винесені в Meta;
-немає бізнес-логіки всередині моделі;
-модель легко читати, розширювати та підтримувати.
1.7 Оформлення views у Django
Views — це одна з ключових частин Django-проєкту, яка відповідає за обробку HTTP-запитів та формування відповідей. Правильне оформлення представлень напряму впливає на читабельність, підтримуваність та структурованість коду.
1.7.1 Основні принципи оформлення views
1. Перевага за Class-Based 
Views (CBV) Class-Based Views роблять код:
            * структурованішим;
            * повторно використовуваним;
            * легшим для розширення;
            * простішим для тестування.
Function-Based Views доцільні лише для примітивних випадків.
2. View повинні бути «тонкими»
У view не повинно бути бізнес-логіки. Уся логіка виноситься до:
            * services/
            * методів моделей (лише поведінка, притаманна сутності)
            * менеджерів моделей (objects)
            * утилітних функцій
View мають лише:
            * прийняти запит
            * викликати бізнес-логіку
            * повернути відповідь (HTML/JSON)


3. Чітке визначення template_name
У CBV завжди слід оголошувати template_name явно, щоб уникати плутанини.
4. Метод у Django повинен виконувати одну дію
Методи класу мають бути короткими, відповідати SRP (Single Responsibility Principle).
5. Перший аргумент методів CBV — self
Це стандарт Python та Django, який забезпечує правильний доступ до:
            * атрибутів класу
            * self.request
            * контексту view


У моделях не повинно бути логіки, яка залежить від запиту, сесії або користувача.


/Java/
# Поганий приклад
# Занадто багато логіки у view, дублювання, відсутній template_name
def orders(request):
    user = request.user
    orders = Order.objects.filter(user=user)


    # Бізнес-логіка прямо у view
    for order in orders:
        order.total = order.price * order.quantity


    if request.GET.get("sort") == "date":
        orders = orders.order_by("-created_at")


    return render(request, "order_list.html", {"orders": orders})
-Function-Based View замість CBV;
-бізнес-логіка всередині view → порушення архітектури;
-обчислення total прямо у циклі;
-змішано поведінку view + бізнес-логіку + сортування;
-відсутнє використання сервісів;
-незрозумілий template шлях;
-складність зростає при додаванні нових функцій.

/Java/
# Гарний приклад
class OrderListView(ListView):
    """Відображає список замовлень користувача."""


    model = Order
    template_name = "shop/order_list.html"


    def get_queryset(self):
        """
        Повертає лише ті замовлення, що належать авторизованому користувачу.
        Використовується для персоналізованого списку замовлень.
        """
        return Order.objects.filter(user=self.request.user)
-використано Class-Based View (ListView);
-view «тонкий» та не містить бізнес-логіки;
-шаблон визначений явно через template_name;
-фільтрація винесена у get_queryset() — стандартна практика Django;
-код короткий, читабельний і розширюваний;
-клас легко розширити (наприклад, додати пагінацію або сортування);
-усе структуровано відповідно до архітектури MVC/MVT.
1.8 Оформлення URL-маршрутів у Django
Правильне структурування URL-маршрутів є важливою частиною підтримуваності Django-проєкту. Чисті, зрозумілі та логічні маршрути спрощують навігацію, зменшують дублювання та допомагають уникати помилок у шаблонах.
1.8.1 Основні принципи оформлення URL-конфігурацій
1. Використовувати path()
path() — коротший, безпечніший і підтримує конвертери типів:
            * <int:id>
            * <slug:slug>
            * <str:username>

2. Один маршрут = одна view
Кожен URL повинен однозначно відповідати певному представленню.
3. Групувати маршрути у логічні модулі
Маршрути слід розділяти за додатками:
               * shop/urls.py
               * users/urls.py
               * orders/urls.py
А головний project/urls.py лише підключає їх.
4. Уникати довгих і складних шляхів
Шлях має бути:
               * коротким,
               * зрозумілим,
               * передбачуваним.


5. Завжди вказувати аргумент name=""
Це необхідно для:
               * використання в шаблонах через {% url %},
               * зручного рефакторингу,
               * генерації посилань у тестах.






/Java/
# Поганий приклад
urlpatterns = [
    path("orderslist", OrderListView.as_view()),
    path("OrderDetailView/<int:id>", order_detail_view),
]


-відсутні параметри name="";
-перший маршрут має некоректну назву: "orderslist" замість "orders/";
-другий маршрут використовує ім’я view у URL (OrderDetailView) — грубе -порушення стилю;
-змішані способи написання (camelCase + PascalCase);
-немає / наприкінці — потенційна проблема редиректів;
-не дотримано стилю Django URL naming conventions.

/Java/
# Гарний приклад
urlpatterns = [
    path("orders/", OrderListView.as_view(), name="order_list"),
    path("orders/<int:id>/", OrderDetailView.as_view(), name="order_detail"),
]
-маршрути короткі та логічні;
-name="order_list" та name="order_detail" — правильні, зрозумілі імена;
-використано Class-Based Views (.as_view());
-коректно додано / наприкінці кожного шляху;
-конвертер <int:id> відповідає синтаксису Django;
-стилістика збігається з Django code style;
-URL-структура відразу зрозуміла та зручна для шаблонів.
1.9 Методи у Django
Методи у Django є ключовими елементами, що визначають поведінку моделей, класових представлень (views) та сервісів. Коректне оформлення методів забезпечує структурованість, зрозумілість та легку підтримку коду в командних проєктах.
1.9.1 Загальні принципи оформлення методів
1. Одне призначення — один метод
Кожен метод повинен виконувати одну логічну дію. Якщо метод одночасно отримує дані, обробляє їх та формує відповідь — його слід розділити.
2. Чіткі та змістовні назви
Назва методу повинна однозначно описувати його поведінку:
               * get_queryset()
               * apply_discount()
               * calculate_total()
               * get_order_by_id()
Методи завжди пишуться в snake_case, що відповідає стандартам Python і Django.
3. Аргумент self — обов’язковий у методах класів
У моделі, view або сервісному класі методи завжди приймають self, щоб мати доступ до атрибутів об'єкта.
4. Мінімум логіки у views
Методи у Django views мають бути «тонкими»: тільки координація запиту, виклик сервісів і передача даних у шаблон.
5. Методи моделей — поведінка сутності, а не бізнес-логіка
У моделі дозволяється:
               * короткі методи доступу (get_full_name(), is_active_user()),
               * допоміжна поведінка, пов’язана з самою сутністю.
Заборонено:
               * робити складні обчислення,
               * працювати з HTTP,
               * виконувати бізнес-логіку або сторонні сервіси.
Повторна логіка — у services/
Методи сервісів пишуться як окремі функції або класи. Вони не залежать від HTTP чи шаблонів і можуть використовуватися повторно.
/Java/
# Поганий приклад
def process(request, id):
    order = Order.objects.get(id=id)


    if order.total > 1000:
        discount = order.total * 0.9
    else:
        discount = order.total


    return HttpResponse(f"Total: {discount}")


-метод виконує одразу три дії: отримує дані, обробляє їх, повертає відповідь;
-бізнес-логіка всередині view;
-погана назва: незрозуміло, що робить метод.


/Java/
# Гарний приклад
# services/order_service.py
def calculate_discount(order):
    return order.total * 0.9 if order.total > 1000 else order.total


# views.py
def order_view(request, id):
    order = Order.objects.get(id=id)
    total = calculate_discount(order)
    return render(request, "shop/order.html", {"total": total})


-view мінімалістичний і чистий;
-бізнес-логіка винесена у service;
-методи мають чіткі, зрозумілі назви;
-легко підтримувати та розширювати.
1.10 Правила оформлення Django Templates
Django Templates призначені для відображення даних, а не для виконання логіки. Тому правильне оформлення шаблонів дозволяє зберігати чистоту коду, розмежовувати відповідальності та спрощувати підтримку проєкту. Шаблони мають бути максимально простими, зрозумілими та не містити бізнес-логіки.
1.10.1 Основні принципи оформлення шаблонів
               * Шаблони НЕ повинні містити бізнес-логіки: У шаблонах заборонено виконувати розрахунки, умови із складною логікою, перевірки статусів або доступів, обчислення сум, знижок тощо. Усі такі операції винносяться у views, services або моделі.
               * Мінімум умов та циклів: Допускається простий контроль відображення через {% if %} та базові цикли {% for %}.
Все, що складніше — має оброблятись у Python-коді до передачі у шаблон.
               * Читабельність та структура HTML
               * Шаблон повинен бути:
                  1. відформатований,
                  2. логічно розбитий,
                  3. містити чітку ієрархію HTML,
                  4. без зайвих вкладених умов.
                  * Використання змінних — у форматі {{ variable_name }}
                  * Не допускається:
                  1. виклик методів із логікою,
                  2. обчислення типу {{ price * quantity }},
                  3. доступ до складних структур всередині шаблону.
                  * Прості перевірки — лише через {% if %}
                  * Умови мають виглядати максимально мінімалістично, без вкладених блоків.
                  * У шаблонах НЕ повинно бути:
                  1. стилів у <style>,
                  2. великих фрагментів JS,
                  3. inline-скриптів.

/Java/
# Поганий приклад
{% if user.orders.count > 0 %}
    {% for o in user.orders.all %}
        {{ o.price * o.quantity }}
    {% endfor %}
{% endif %}


-виконується обчислення price * quantity → бізнес-логіка в шаблоні;
-user.orders.count — запит до бази даних у шаблоні;
-складний цикл зі зверненням до ORM;
-важко підтримувати та тестувати таку конструкцію;
-порушено принцип розмежування відповідальностей.

/Java/
# Гарний приклад
{% if orders %}
    {% for order in orders %}
        {{ order.total }}
    {% endfor %}
{% endif %}


-усі обчислення винесені у view/service;
-шаблон відображає лише готові дані;
-простий цикл та проста перевірка;
-шаблон чистий, читабельний і структурований;
-відповідає Django Template Style Guide.














































2 Висновки
Правильне оформлення коду — це фундаментальна складова професійної розробки, яка забезпечує якість, масштабованість та довготривалий життєвий цикл програмного продукту. У контексті Django, де проєкт складається з великої кількості файлів, застосунків, моделей, сервісів, маршрутів і шаблонів, дотримання правил стилю стає не просто рекомендацією, а необхідністю. Відсутність єдиної системи оформлення призводить до хаосу в кодовій базі, ускладнює командну роботу, уповільнює перевірку, збільшує кількість помилок і ускладнює масштабування проєкту.
Стандартизація коду, зокрема PEP 8 та Django Style Guide, створює спільне інформаційне середовище для всіх розробників — незалежно від їх рівня досвіду. Єдині правила відступів, оформлення дужок, іменування змінних, структурування проєкту й логічного розподілення відповідальності дають змогу підтримувати високий рівень читабельності та зрозумілості коду. Команда працює як єдиний механізм, а onboarding нових розробників стає значно швидшим і менш ресурсозатратним.
Особливо важливим є розділення логіки між різними рівнями Django: views, service layer, моделі та шаблони. Чітке дотримання принципів “тонких views” і винесення бізнес-логіки у сервіси зменшує навантаження на представлення та підвищує тестованість коду. Моделі виконують роль опису сутностей, а не місця для важких обчислень. Шаблони, у свою чергу, мають залишатися простими та позбавленими логіки, оскільки їхня єдина функція — відобразити підготовлені дані. Усі складні умови, цикли та обчислення мають виконуватися до передачі інформації в HTML.
Таким чином, правила стилю кодування — це не формальність і не данина традиції. Це інструмент, що гарантує високу якість продукту, підвищує ефективність команди, захищає проєкт від технічного боргу та помилок, робить розробку більш передбачуваною і приємною.Це особливо актуально для Django-проєктів, де правильна структура і чистота коду напряму впливають на швидкість розробки, стабільність застосунку та зручність роботи всієї команди.










3. ВИКОРИСТАНІ ДЖЕРЕЛА


3.1 Офіційна документація
                     1. PEP 8 – Style Guide for Python Code [Електронний ресурс]. — Режим доступу:
 https://peps.python.org/pep-0008/
 Офіційний стиль-керівник Python, що визначає правила форматування коду, іменування, відступів та структури програм.
                     2. Django Documentation [Електронний ресурс]. — Режим доступу:
 https://docs.djangoproject.com/
 Офіційна документація Django, яка охоплює моделі, маршрути, шаблони, CBV, конфігурацію та інструменти для побудови веб-додатків.
                     3. Django Coding Style [Електронний ресурс]. — Режим доступу:
https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/
 Рекомендації щодо стилю коду Django, включаючи вимоги до імпортів, структури модулів, оформлення тестів та документування.
                     4. Python Standard Library Reference [Електронний ресурс]. — Режим доступу:
 https://docs.python.org/3/library/
 Офіційний довідник стандартної бібліотеки Python.
3.2 Документація інструментів
                        5. Black Formatter Documentation [Електронний ресурс]. — Режим доступу:
 https://black.readthedocs.io/
 Документація автоматичного форматера коду Python Black, який забезпечує єдиний стиль проєкту.
                        6. Flake8 Documentation [Електронний ресурс]. — Режим доступу:
 https://flake8.pycqa.org/
 Опис інструменту статичного аналізу коду Python, що контролює стиль та виявляє помилки.
3.3 Додаткові ресурси
                           7. McConnell S. Code Complete: A Practical Handbook of Software Construction. — Microsoft Press, 2004. — 960 р.
Фундаментальна книга про стандарти програмування, форматування коду та проєктування архітектури.

                           8. Django Best Practices Guide [Електронний ресурс]. — Режим доступу:
 https://docs.djangoproject.com/en/dev/misc/design-philosophies/
































































ДОДАТОК А
Відеозапис


Відеозапис доповіді: https://youtu.be/ieo8J1Rn3iQ
Хронологічний опис відеозапису:
00:00 Вступ
00:11 Для чого потрібен Django
00:34 Структура Django-проєкту( онлайн магазин)
01:02 Загальні правила оформлення коду (PEP 8)
02:09 Імпорти та порядок
02:56 Офромлення функцій у Django
03:57 Оформлення моделей у Django
04:56 Оформлення views/методів у Django
06:03 Форматування коду у Django
07:07 Оформлення URL-маршрутів у Django
08:07 Service Layer у Django
08:52 Правила оформлення Django Templates
09:45 Висновки
10:17 Джерела






























ДОДАТОК Б
Слайди презентації


  

Рисунок Б.1 - Правила оформлення Python-коду для веб-розробки y Django


  

Рисунок Б.2 - Для чого потрібен Django
  

Рисунок Б.3 - Структура Django-проєкту(онлайн магазин)


  

Рисунок Б.4 - Загальні правила оформлення коду (PEP 8)
  

Рисунок Б.5 - Імпорти та порядок (PEP 8 + Django)


  

Рисунок Б.6 - Правила оформлення Python-коду для веб-розробки y Django
  

Рисунок Б.7 - Оформлення моделей у Django


  

Рисунок Б.8 - Оформлення views/методів ц Django
  

Рисунок Б.9 - Форматування коду у Django


  

Рисунок Б.10 - Оформлення URL-маршрутів у Django
  

Рисунок Б.11 - Service Layer у Django(винесення бізнес-логіки)


  

Рисунок Б.12 - Правила оформлення Django Templates
  

Рисунок Б.13 - Висновки


  

Рисунок Б.14 - Джерела












ДОДАТОК В
Програмний код
В.1 Приклад моделі Django до рефакторингу
 1  class userprofile(models.Model):
 2      #профіль
 3      FIrstName = models.CharField(max_length=50)
 4
 5      def GetUser(ID):
 6          """Ідентифікатор."""
 7          return User.objects.get(ID=ID)


В.2 Приклад моделі Django після рефакторингу
 1  class UserProfile(models.Model):
 2      """Модель профілю користувача з правильним оформленням імен."""
 3
 4      first_name = models.CharField(max_length=50)
 5
 6  def get_user(id: int):
 7      """Повертає користувача за його ідентифікатором."""
 8      return User.objects.get(id=id)


B.3 Приклад  імпорту до рефакторингу
 1  from .service import calculate
 2  import django
 3  import os, sys
 4  from django.db import models


B.4 Приклад  імпорту після рефакторингу
 1  import os
 2  import sys
 3
 4  import requests
 5
 6  from django.db import models
 7  from django.http import HttpRequest
 8
 9  from app.services.order_service import calculate_total


В.5 Views і логіка до рефакторингу 
 1  def data(request, id):
 2      # Ім’я не описує дію, логіка у view, відсутні типи
 3      order = Order.objects.get(pk=id)
 4      order.total = order.price * order.quantity
 5      return order


В.6 Views і логіка після рефакторингу
 1  def get_order_by_id(order_id: int) -> Order:
 2      """Чітка назва, логіка винесена у service."""
 3      return Order.objects.get(id=order_id)
 4
 5  def order_detail_view(request, order_id: int):
 6      """View лише викликає сервіс і повертає дані."""
 7      order = get_order_by_id(order_id)
 8      return render(request, "shop/order_detail.html", {"order": order})


В.7 Коректне оформлення Django-моделі
1  class Order(models.Model):
2      """Модель замовлення. Зберігає загальну суму та користувача."""
3
4      user = models.ForeignKey(User, on_delete=models.CASCADE)
5      total = models.DecimalField(max_digits=10, decimal_places=2)
6      created_at = models.DateTimeField(auto_now_add=True)
7
8      def __str__(self) -> str:
9          return f"Order #{self.id}"
10
11      class Meta:
12          ordering = ["-created_at"]


B.8 Class-Based View
1  class OrderListView(ListView):
2      """Відображає список замовлень користувача."""
3
4      model = Order
5      template_name = "shop/order_list.html"
6
7      def get_queryset(self):
8          """Повертає лише ті замовлення, що належать користувачу."""
9          return Order.objects.filter(user=self.request.user)


B.9 create_order до рефакторингу
1  def create_order(
2      user, product,
3      qty):
4      return Order.objects.create(
5          user=user,
6          product=product,
7          quantity=qty)


B.10 create_order після рефакторингу
1  def create_order(
2      user: User,
3      product: Product,
4      quantity: int,
5  ) -> Order:
6      return Order.objects.create(
7          user=user,
8          product=product,
9          quantity=quantity,
10      )


В.11 URL-маршрути до рефакторингу
1  urlpatterns = [
2      path("orderslist", OrderListView.as_view()),
3      path("OrderDetailView/<int:id>", order_detail_view),
4  ]


В.12 URL-маршрути після рефакторингу
1  urlpatterns = [
2      path("orders/", OrderListView.as_view(), name="order_list"),
3      path("orders/<int:id>/", OrderDetailView.as_view(), name="order_detail"),
4  ]


В.13  Service Layer
1  # services/order_service.py
2  def apply_discount(order):
3      """Повертає фінальну ціну замовлення з урахуванням знижки."""
4      if order.total > 1000:
5          return order.total * 0.9
6      return order.total


B.14 Django Templates до рефакторингу
1  {% if user.orders.count > 0 %}
2      {% for o in user.orders.all %}
3          {{ o.price * o.quantity }}
4      {% endfor %}
5  {% endif %}
6  {# Це бізнес-логіка! #}


B.15 Django Templates до рефакторингу
1  {% if orders %}
2      {% for order in orders %}
3          {{ order.total }}
4      {% endfor %}
5  {% endif %}