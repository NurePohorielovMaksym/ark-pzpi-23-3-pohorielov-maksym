МІНІСТЕРСТВО НАУКИ І ОСВІТИ УКРАЇНИ


ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ










Кафедра «Програмна інженерія»








ЗВІТ
з лабораторної роботи №4
 з дисципліни: «Аналіз та рефакторинг коду»
з теми: «Програмна система для автоматизації годування домашніх тварин»










 
Виконав:                                                                   Прийняв:
ст. гр. ПЗПІ-23-3                                                      ст. викл. каф. ПІ
Погорєлов М. І.                                                        Сокорчук Ігор Петрович




















Харків 2025
1. ІСТОРІЯ ЗМІН


№
	Дата
	Опис змін
	Версія звіту
	1
	26.12.2025
	початок роботи
	0.1
	2
	27.12.2025
	редагування попередньої версії
	1
	

2. ЗАВДАННЯ


 Метою роботи є розробка програмного забезпечення для  IoT або SmartDevice пристрою, створеного на базі будь-якої поширеної на  сьогодні платформи, придатної для реалізації вбудованих систем (Embedded  System). Пристрій повинен бути частиною програмної системи і повинен взаємодіяти з нею. Програмне забезпечення повинно реалізовувати розширену функціональність, що відповідає концепції IoT або SmartDevice, та забезпечувати взаємодію з  іншими частинами системи. 


3. ОПИС ВИКОНАНОЇ РОБОТИ
3.1 Архітектурні рішення IoT клієнта
IoT клієнт побудований на базі мікроконтролера ESP32, який виступає центральним вузлом керування годівницею. Архітектура програмного забезпечення є модульною та подійно-орієнтованою:
Компонентна архітектура:
* Сенсорний рівень:
1. Потенціометр: використовується для емуляції плину часу (мапінг аналогового сигналу у 24-годинний формат) для демонстрації роботи розкладу.
2. Фізична кнопка: для ручної ініціалізації видачі корму (Manual Feed).
* Логічний рівень (Controller):
1. Time Emulation Module: модуль перерахунку значень потенціометра у віртуальний час.
2. Scheduler Engine: модуль локального зберігання та перевірки розкладів годування (порівняння віртуального часу з часом у масиві розкладів).
* Комунікаційний рівень:
1. WiFi Client: підтримка стабільного з'єднання.
2. API Handler: серіалізація/десеріалізація JSON-об'єктів (бібліотека ArduinoJson) для обміну даними з сервером.
* Виконавчий рівень:
1. Servo Controller: керування сервоприводом (генерація PWM сигналу) для відкриття/закриття заслонки бункера.
2. LED Indication: візуалізація статусу (Online/Offline/Error) та процесу видачі корму.


  



Рисунок 3.1 – Структурна схема IoT частини системи


Принципи проектування:
* Автономність: пристрій кешує розклад локально, що дозволяє виконувати годування навіть при тимчасовій втраті зв'язку з сервером.
* Стійкість до збоїв: реалізовано механізми перепідключення (Soft Reconnect) та обробки тайм-аутів HTTP-запитів.
* Синхронізація: регулярне оновлення конфігурації для актуалізації планів харчування, створених користувачем у додатку.
3.2 Вибір методів комунікації та протоколів
Взаємодія між IoT-клієнтом та сервером реалізована через REST API поверх протоколу HTTP/1.1. Цей вибір зумовлений використанням Node.js на серверній стороні та необхідністю передачі складних структур даних (масивів розкладів), див. рисунок 3.2, ДОДАТОК Б. Схема обміну даними: 
ESP32 (Client) ⇄ JSON over HTTP ⇄ Node.js Express (Server).
Використані ендпоінти API: Для забезпечення повноцінної роботи системи реалізовано наступні маршрути:
* GET /my-pet-profile — завантаження актуальних налаштувань та розкладу годування.
* POST /heartbeat — регулярна (кожні 30 с) відправка "пульсу" для підтвердження статусу Online та отримання миттєвих команд (feed-now).
* POST /feeding-events/add — відправка звіту про успішну видачу корму (або помилку механізму) для збереження історії в базі даних.
* POST /schedules//pets/:petId/feed-now - кнопка погодувати зараз.
* POST /schedules/pets/:petId/feed-auto - автоматичне годування.
* POST /:deviceId/refill - поповнення рівня корму.
Вибір HTTP замість MQTT обґрунтований спрощенням інфраструктури (відсутність необхідності у брокері повідомлень) та достатністю синхронної моделі запитів для даного типу задач.
3.3 Бізнес-логіка та алгоритми роботи
Логіка роботи пристрою базується на моделі скінченного автомата (State Machine) з пріоритетом на виконання розкладу, див. рисунок 3.3, ДОДАТОК Б. Цикл роботи системи:
1. Ініціалізація: При старті пристрій підключається до Wi-Fi та запитує у сервера актуальний профіль годування (fetchPetProfile).
2. Моніторинг часу: У головному циклі мікроконтролер зчитує значення емулятора часу або реального таймера.
3. Прийняття рішень:
* Перевірка розкладу: Порівняння поточного часу з масивом таймерів у пам'яті.
* Перевірка команд: Обробка відповіді на heartbeat (чи є команда годувати негайно).
* Обробка кнопки: Чи натиснув користувач фізичну кнопку.
4. Виконання дії: При спрацюванні будь-якої умови активується сервопривід. Система виконує поворот на заданий кут, очікує висипання порції та повертається у вихідне положення.
5. Валідація та звітність: Після завершення механічної дії пристрій формує JSON-пакет із даними про подію (час, розмір порції, джерело команди — AUTO/MANUAL) та надсилає його на сервер.
Такий підхід гарантує цілісність даних: сервер завжди знає, чи була тварина погодована фактично, а не лише теоретично за розкладом.


4 ФРАГМЕНТИ ПРОГРАМНОГО КОДУ
4.1 Код ініціалізації та системної конфігурації
Функція setup() є точкою входу в програму. Вона виконує послідовну ініціалізацію: налаштування послідовного порту для дебагу, конфігурацію пінів (вхід/вихід) та підключення сервоприводу. Особливістю реалізації є блокуючий виклик fetchPetProfile() — система не перейде до основного циклу, доки не отримає конфігурацію з сервера, що гарантує коректність прив'язки даних (petId, deviceId) перед початком роботи:


void setup() {
  Serial.begin(115200);
  // Налаштування периферії
  pinMode(BTN_FEED_PIN, INPUT_PULLUP);
  feeder.attach(SERVO_PIN);
  feeder.write(0); // Встановлення безпечного стану механізму


  setLED("starting");
  connectWiFi();


  // Критична секція: завантаження профілю
  if (fetchPetProfile()) {
    state.isConnected = true;
    fetchSchedules();
    updateLEDIndicators();
    Serial.println("Система успішно ініціалізована ✓");
  } else {
    // Блокування роботи у випадку помилки авторизації
    setLED("error");
  }
}


Функція connectWiFi() реалізує алгоритм підключення до мережі з механізмом тайм-ауту (Watchdog). Цикл while обмежений лічильником спроб (25 разів), що запобігає "зависанню" контролера у нескінченному циклі при відсутності мережі. У разі успіху IP-адреса виводиться в консоль для діагностики:


void connectWiFi() {
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts++ < 25) {
    delay(400);
    Serial.print(".");
  }
  // ... логіка виводу статусу з'єднання
}
4.2 Код взаємодії з API (REST Client)
Функція fetchPetProfile() виконує динамічну конфігурацію пристрою. Вона робить GET-запит на сервер, використовуючи унікальний серійний номер DEVICE_SERIAL. Отримана JSON-відповідь містить критичні параметри: ідентифікатор тварини (petId), рекомендований розмір порції та загальну ємність контейнера. Це дозволяє використовувати одну й ту саму прошивку для різних пристроїв без перекомпіляції:


bool fetchPetProfile() {
  HTTPClient http;
  // Формування динамічного URL
  String url = String(SERVER_URL) + "/api/devices/my-pet-profile/" + String(DEVICE_SERIAL);
  
  http.begin(url);
  http.addHeader("x-device-key", DEVICE_API_KEY); // Авторизація за API Key


  int code = http.GET();
  if (code == 200) {
    // Десеріалізація налаштувань
    StaticJsonDocument<512> doc;
    deserializeJson(doc, http.getString());
    
    state.petId = doc["profile"]["petId"];
    state.recommendedPortion = doc["profile"]["recommendedPortionGrams"];
    return true;
  }
  return false;
}


Функція sendHeartbeat() відповідає за моніторинг стану пристрою ("Keep-Alive"). Вона періодично надсилає короткий запит на сервер, підтверджуючи, що пристрій онлайн і готовий приймати команди. Це дозволяє відображати актуальний статус "Online" в інтерфейсі користувача:
void sendHeartbeat() {
  if (!state.isConnected) return;
  
  HTTPClient http;
  String url = String(SERVER_URL) + "/api/devices/heartbeat";
  
  StaticJsonDocument<64> doc;
  doc["deviceId"] = state.deviceId;
  
  // Відправка легкого JSON для економії трафіку
  String json;
  serializeJson(doc, json);
  http.POST(json);
  http.end();
}


Функція sendRefillRequest() обробляє логіку поповнення бункера. При натисканні кнопки поповнення, пристрій повідомляє сервер про додавання корму (REFILL_AMOUNT). Сервер оновлює залишки в базі даних і повертає актуальне загальне значення (totalNow), яке синхронізується з локальним станом state.foodLevel:


bool sendRefillRequest(int grams) {
  // ... ініціалізація HTTP ...
  StaticJsonDocument<200> doc;
  doc["grams"] = grams;
  
  int httpCode = http.POST(requestBody);
  
  if (httpCode == 200 || httpCode == 201) {
     // Синхронізація залишків після поповнення
     DynamicJsonDocument response(1024);
     deserializeJson(response, http.getString());
     state.foodLevel = response["data"]["totalNow"];
     updateLEDIndicators(); // Оновлення світлодіода
     return true;
  }
  return false;
}


Функція забезпечує зворотний зв'язок пристрою із сервером після спрацювання автоматичного розкладу. На відміну від ручного запиту (sendFeedRequest), де ми спочатку чекаємо дозволу, тут дія вже виконана, і ми лише повідомляємо результат ("пост-фактум"). Важливою особливістю є обробка відповіді сервера: бекенд повертає актуальний розрахований рівень корму (foodLevel), який записується в пам'ять пристрою:
void reportAutoFeed(int grams) {
  if (WiFi.status() != WL_CONNECTED) return;


  HTTPClient http;
  String url = String(SERVER_URL) + "/api/schedules/pets/" + String(PET_ID) + "/feed-auto";
  
  // Формування звіту: хто, скільки і чим годував
  StaticJsonDocument<200> doc;
  doc["deviceId"] = DEVICE_ID;
  doc["portionGrams"] = grams;
  doc["foodType"] = FOOD_TYPE; 


  String requestBody;
  serializeJson(doc, requestBody);


  int httpCode = http.POST(requestBody);


  // Обробка відповіді для синхронізації стану
  if (httpCode > 0) {
    String payload = http.getString();
    DynamicJsonDocument responseDoc(1024);
    deserializeJson(responseDoc, payload);


    // Оновлення локального лічильника корму даними з сервера
    if (responseDoc["event"].containsKey("foodLevel")) {
       state.foodLevel = responseDoc["event"]["foodLevel"]; 
       updateLEDIndicators(); 
       Serial.printf("[SYNC] Food Level updated: %d g\n", state.foodLevel);
    }
  }
  http.end();
}
4.3 Код бізнес-логіки та керування подіями
Функція handleButtons() забезпечує взаємодію з користувачем через фізичні кнопки. Реалізовано програмний захист від брязкоту контактів (software debouncing) через перевірку часу останнього натискання (now - lastFeed > DEBOUNCE_MS). Функція розрізняє дві події: запит на видачу корму (з перевіркою дозволу від сервера) та запит на поповнення запасів:


void handleButtons() {
  unsigned long now = millis();


  // Обробка кнопки "Годування"
  if (digitalRead(BTN_FEED_PIN) == LOW && now - lastFeed > DEBOUNCE_MS) {
    lastFeed = now;
    // Синхронний запит дозволу на сервері
    if (sendFeedRequest(state.recommendedPortion)) {
      executeDispense(state.recommendedPortion);
    } else {
      setLED("error"); // Індикація відмови
    }
  }
  
  // Обробка кнопки "Поповнення" (аналогічно)...
}


Функція checkAutoFeeding() є ядром автоматизації. Вона працює на основі емульованого часу (для цілей тестування) або реального часу. Алгоритм порівнює поточну хвилину доби з масивом розкладів schedules. Якщо час співпадає і розклад активний (enabled), ініціюється видача корму, оновлюється локальний рівень залишків та надсилається асинхронний звіт (reportAutoFeed) на сервер:


void checkAutoFeeding() {
  // ... отримання поточного часу ...
  for (int i = 0; i < schedules.count; i++) {
      auto& sch = schedules.items[i];
      // Перевірка збігу часу
      if (sch.enabled && sch.hour == h && sch.minute == m) {
        
        executeDispense(sch.portionGrams); // Фізична дія
        state.foodLevel -= sch.portionGrams; // Локальний облік
        
        reportAutoFeed(sch.portionGrams); // Звіт на бекенд
        updateLEDIndicators();
      }
  }
}


Функція simulateTimeFromPot() використовується для демонстрації роботи пристрою. Вона зчитує аналогове значення з потенціометра (0-4095) і масштабує його у хвилини доби (0-1439). Це дозволяє швидко перевірити роботу розкладу без необхідності чекати реального настання часу годування:


void simulateTimeFromPot() {
  int raw = analogRead(POT_TIME_PIN);
  // Маппінг: 0...4095 -> 00:00...23:59
  state.simulatedMinutes = map(raw, 0, 4095, 0, 1439);


  // Логування зміни часу для налагодження
  if (state.simulatedMinutes != state.lastMinutes) {
    int h = state.simulatedMinutes / 60;
    int m = state.simulatedMinutes % 60;
    Serial.printf("[TIME] %02d:%02d\r\n", h, m);
    state.lastMinutes = state.simulatedMinutes;
  }
}


Функція updateLEDIndicators() та setLED() забезпечують візуальний зворотний зв'язок. Логіка індикації базується на залишках корму: якщо рівень падає нижче порогу LOW_FOOD_THRESHOLD_PCT (30%), загоряється червоний світлодіод, попереджаючи власника. Зелений колір свідчить про нормальний стан. Функція setLED дозволяє тимчасово перехоплювати керування для відображення системних подій (помилка, старт, успішна операція):


void updateLEDIndicators() {
  if (state.capacity <= 0) return;
    int pct = (state.foodLevel * 100L) / state.capacity;
  // Логіка перемикання кольорів залежно від залишку
  if (pct > LOW_FOOD_THRESHOLD_PCT) {
    digitalWrite(LED_GREEN_PIN, HIGH); // Норма
    digitalWrite(LED_RED_PIN, LOW);
  } else {
    digitalWrite(LED_GREEN_PIN, LOW);
    digitalWrite(LED_RED_PIN, HIGH);   // Увага
  }
}


Функція відповідає за фізичне керування механікою дозатора. Вона інкапсулює роботу з бібліотекою ESP32Servo. Ключовим моментом є алгоритм конвертації "бізнес-величини" (грами) у "апаратну величину" (час роботи мотора). Використовується коефіцієнт 12 мс/г, визначений експериментальним шляхом для конкретного типу шнека. Логіка роботи: відкрити заслінку (90°) -> чекати розрахунковий час -> закрити заслінку (0°):


void executeDispense(int grams) {
  Serial.printf("[SERVO] Видача %d г... ", grams);
  
  feeder.write(90);       // Поворот сервоприводу у відриту позицію
  delay(grams * 12);      // Блокуюча затримка для точного дозування
  feeder.write(0);        // Повернення у закриту позицію
  
  Serial.println("виконано");
}
4.5 Код логіки візуальної індикації
Функція працює у фоновому режимі та викликається в кожній ітерації головного циклу. Вона конвертує абсолютне значення ваги (грами) у відносне (відсотки) та порівнює його з пороговим значенням 30%:
* Зелений індикатор: Рівень корму в нормі.
* Червоний індикатор: Критично низький рівень, потрібне втручання користувача.


void updateLEDIndicators() {
  // Захист від ділення на нуль
  if (state.capacity <= 0) return; 


  // Розрахунок відсотка залишку
  int pct = (state.foodLevel * 100L) / state.capacity;


  // Логіка перемикання кольорів
  if (pct > LOW_FOOD_THRESHOLD_PCT) {
    digitalWrite(LED_GREEN_PIN, HIGH); // Все добре
    digitalWrite(LED_RED_PIN, LOW);
  } else {
    digitalWrite(LED_GREEN_PIN, LOW);
    digitalWrite(LED_RED_PIN, HIGH);   // УВАГА: мало корму
  }
}
Функція забезпечує миттєвий зворотний зв'язок на дії користувача (натискання кнопок) або системні збої. Вона тимчасово перехоплює керування світлодіодами, відтворює заданий патерн (анімацію), а потім автоматично повертає систему до відображення рівня запасів.Реалізовані режими:
1. "error": Тривале блимання червоним (помилка мережі, відмова сервера).
2. "starting": Одночасне світіння обох діодів (тест справності при запуску).
3. "ok": Короткий зелений сигнал (успішне виконання операції).


void setLED(const char* mode) {
  // Сценарій 1: Помилка (блимання червоним 3 рази)
  if (strcmp(mode, "error") == 0) {
    digitalWrite(LED_GREEN_PIN, LOW); 
    for (int i = 0; i < 3; i++) {
      digitalWrite(LED_RED_PIN, HIGH); delay(200);
      digitalWrite(LED_RED_PIN, LOW);  delay(200);
    }
  } 
  // Сценарій 2: Завантаження системи
  else if (strcmp(mode, "starting") == 0) {
    digitalWrite(LED_RED_PIN, HIGH);
    digitalWrite(LED_GREEN_PIN, HIGH);
    delay(1000);
  } 
  // Сценарій 3: Успішна дія
  else if (strcmp(mode, "ok") == 0) {
    digitalWrite(LED_RED_PIN, LOW);
    digitalWrite(LED_GREEN_PIN, HIGH);
    delay(400); // Коротка фіксація успіху
  }
  updateLEDIndicators();
}








5 ВИСНОВКИ


У даній роботі реалізовано програмне забезпечення IoT-годівниці на базі ESP32, що забезпечує автоматизовану видачу корму за розкладом та дистанційний контроль запасів. Розроблена прошивка підтримує двосторонній обмін даними з сервером через REST API, дозволяючи динамічно завантажувати налаштування профілю та синхронізувати історію годувань у форматі JSON. Застосування неблокуючого алгоритму керування гарантує одночасну обробку користувацьких команд з кнопок, точне позиціювання сервоприводу та візуальну індикацію стану системи, забезпечуючи автономну та надійну роботу пристрою.




6 ВИКОРИСТАНІ ДЖЕРЕЛА


1. ArduinoJson Documentation: Efficient JSON serialization for embedded C++ [Електронний ресурс]. – Режим доступу: https://arduinojson.org/ – Дата доступу: 12.01.2026.
2. ESP32Servo Library Documentation [Електронний ресурс]. – Режим доступу: https://github.com/madhephaestus/ESP32Servo – Дата доступу: 12.01.2026.
3. Arduino Language Reference [Електронний ресурс]. – Режим доступу: https://www.arduino.cc/reference/en/ – Дата доступу: 12.01.2026.






































ДОДАТОК А


Відеозапис


Відеозапис доповіді: https://youtu.be/jwEF1_U8t6k


Хронологічний опис відеозапису:
00:00 - Вступ
00:47 - Ініціалізація програми
01:31 - Автоматичне годування
02:22 - Ручне годування
03:02 - Поповнення корму
































































ДОДАТОК Б




  

Рисунок 3.2 – UML діаграма прецедентів IoT клієнта
  

Рисунок 3.3 – UML діаграма діяльності IoT клієнта